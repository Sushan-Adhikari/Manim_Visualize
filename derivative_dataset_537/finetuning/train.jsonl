{"function": "x^2 + 5*x + 6", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 45, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + 5*x + 6\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + 5x + 6\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + 5x + 6\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rules: } \\frac{d}{dx}[x^n] = nx^{n-1}, \\frac{d}{dx}[cx] = c\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + 5 + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x + 5\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x + 5\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quad 5x plus 6", "metadata": {"attempts": 1, "code_length": 3499}}
{"function": "sqrt(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{2x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sqrt{2x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[g(x)^n] = n g(x)^{n-1} g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}(2x)^{-1/2} \\cdot 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{\\sqrt{2x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / np.sqrt(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled root input", "metadata": {"attempts": 1, "code_length": 3529}}
{"function": "-x^4 + x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**4 + x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{4} + x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{4} + x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -4x^{3} + 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -4x^{3} + 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -4*x**3 + 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative quartic quad", "metadata": {"attempts": 1, "code_length": 3494}}
{"function": "2*x^4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 50, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{4}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{4}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot 4 x^{3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 8x^{3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 8*x**3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled quartic", "metadata": {"attempts": 1, "code_length": 3461}}
{"function": "e^(x^2)*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x**2) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x^2} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x^2} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x^2}(2x\\sin(x) + \\cos(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x^2}(2x\\sin(x) + \\cos(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x**2) * (2*x*np.sin(x) + np.cos(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "exp square sine", "metadata": {"attempts": 1, "code_length": 3557}}
{"function": "x^3 + 5", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + 5\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + 5\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + 5\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic shifted 5", "metadata": {"attempts": 1, "code_length": 3462}}
{"function": "-cos(x) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 2.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.cos(x) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -\\cos(x) + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -\\cos(x) + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[-\\cos(x)] = \\sin(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\sin(x) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative cosine shifted", "metadata": {"attempts": 1, "code_length": 3465}}
{"function": "-x^2*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**2 * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{2} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{2} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (-2x)\\sin(x) + (-x^{2})\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2x\\sin(x) - x^{2}\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2*x*np.sin(x) - x**2*np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative quad sine", "metadata": {"attempts": 1, "code_length": 3534}}
{"function": "cos(sqrt(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[0, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(np.sqrt(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(\\sqrt{x})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(\\sqrt{x})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g)] = f'(g)g'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(\\sqrt{x}) \\cdot \\frac{1}{2\\sqrt{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{\\sin(\\sqrt{x})}{2\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.sin(np.sqrt(x)) / (2 * np.sqrt(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cosine of root", "metadata": {"attempts": 1, "code_length": 3567}}
{"function": "-x*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\cos(x) + x\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\cos(x) + x\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.cos(x) + x * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative x cosine", "metadata": {"attempts": 1, "code_length": 3501}}
{"function": "e^(sin(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(np.sin(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{\\sin(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{\\sin(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[e^{g(x)}] = e^{g(x)}g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{\\sin(x)} \\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{\\sin(x)} \\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(np.sin(x)) * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exponential of sine", "metadata": {"attempts": 1, "code_length": 3527}}
{"function": "x^2*e^(-x)*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-30, 10, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.exp(-x) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} e^{-x} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} e^{-x} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Prod. Rule: } (uvw)' = u'vw + uv'w + uvw'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = xe^{-x}((2-x)\\sin(x) + x\\cos(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = xe^{-x}((2-x)\\sin(x) + x\\cos(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x * np.exp(-x) * ((2 - x) * np.sin(x) + x * np.cos(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "quad decay sine", "metadata": {"attempts": 1, "code_length": 3600}}
{"function": "sin(x)/2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) / 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\sin(x)}{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{1}{2}\\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\sin(x)] = \\cos(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2}\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x) / 2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "sine divided", "metadata": {"attempts": 1, "code_length": 3492}}
{"function": "ln(x)/sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[0, 4, 1],\n            y_range=[-8, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) / np.sqrt(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\ln(x)}{\\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x) x^{-1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x}x^{-1/2} + \\ln(x)(-\\frac{1}{2}x^{-3/2})\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2 - \\ln(x)}{2x^{3/2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (2 - np.log(x)) / (2 * x**(3/2))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), min(3.5, x_tracker.get_value()+1.5)],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "log over root", "metadata": {"attempts": 1, "code_length": 3591}}
{"function": "(x^2 + x)/(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return (x**2 + x) / (x**2 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x^2 + x}{x^2 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^2 + x}{x^2 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"u'v - uv' = -x^2+2x+1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{-x^2+2x+1}{(x^2+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (-x**2 + 2*x + 1) / ((x**2 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "quad linear over quad", "metadata": {"attempts": 1, "code_length": 3573}}
{"function": "x^2 + 3*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 30, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + 3*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + 3x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + 3x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + 3x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x + 3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x + 3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quadratic linear combo", "metadata": {"attempts": 1, "code_length": 3471}}
{"function": "tan(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.tan(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\tan(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\tan(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\tan(u)] = \\sec^2(u)u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\sec^2(2x) \\cdot 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\\sec^2(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * (1 / np.cos(2*x))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "compressed tangent", "metadata": {"attempts": 1, "code_length": 3501}}
{"function": "0.25*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.25 * x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 0.25x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.25x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.25 \\cdot 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 0.5x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quarter quadratic", "metadata": {"attempts": 1, "code_length": 3469}}
{"function": "-x^2*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-30, 5, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**2 * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{2} e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{2} e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2xe^{x} - x^{2}e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -xe^{x}(2+x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -x * np.exp(x) * (2 + x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "negative quad exp", "metadata": {"attempts": 1, "code_length": 3502}}
{"function": "x^2/(x^3 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 / (x**3 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5], discontinuities=[-1])\n        func_label = MathTex(r\"f(x) = \\frac{x^2}{x^3 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^2}{x^3 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{2x(x^3+1) - 3x^4}{(x^3+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2x - x^4}{(x^3 + 1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            # Handle division by zero for derivative as well\n            if x**3 + 1 == 0:\n                return np.nan # Or some other indicator for undefined\n            return (2*x - x**4) / ((x**3 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "quad over cubic plus", "metadata": {"attempts": 1, "code_length": 3755}}
{"function": "ln(x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x) \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x) \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x}\\cos(x) - \\ln(x)\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos(x)}{x} - \\ln(x)\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (1/x) * np.cos(x) - np.log(x) * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "log cosine product", "metadata": {"attempts": 1, "code_length": 3562}}
{"function": "ln(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5]) # Adjusted x_range for ln(x)\n        func_label = MathTex(r\"f(x) = \\ln(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(u)] = \\frac{u'}{u}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{2}{2x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Adjusted initial value for ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), min(3.5, x_tracker.get_value()+1.5)], # Adjusted x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Adjusted animation target\n        self.wait(1)", "level": "conceptual", "description": "log of scaled x", "metadata": {"attempts": 1, "code_length": 3593}}
{"function": "x^2*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-12, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x\\cos(x) - x^{2}\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\\cos(x) - x^{2}\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x*np.cos(x) - x**2*np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "quadratic times cosine", "metadata": {"attempts": 1, "code_length": 3524}}
{"function": "x^3/(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 / (x**2 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x^3}{x^2 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^3}{x^2 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{3x^2(x^2+1) - x^3(2x)}{(x^2+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{x^4 + 3x^2}{(x^2+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (x**4 + 3*x**2) / ((x**2 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic over quad plus", "metadata": {"attempts": 1, "code_length": 3580}}
{"function": "sin(x) + e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 60, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) + np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x) + e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x) + e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Sum Rule: } (u+v)' = u'+v'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x) + e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x) + e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x) + np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine plus exp", "metadata": {"attempts": 1, "code_length": 3500}}
{"function": "e^x - 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2.5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) - 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} - 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} - 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^x \\pm c] = e^x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x} - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "exponential shifted -2", "metadata": {"attempts": 1, "code_length": 3450}}
{"function": "x^3 + x^2 + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-50, 70, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + x**2 + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + x^{2} + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + x^{2} + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 2x^{1} + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 2x + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 2*x + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic quad linear", "metadata": {"attempts": 1, "code_length": 3514}}
{"function": "sin(x)/(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 1, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) / (x**2 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\sin(x)}{x^{2} + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\sin(x)}{x^{2} + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"(\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\cos(x)(x^2+1) - 2x\\sin(x)}{(x^2+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos(x)(x^2+1) - 2x\\sin(x)}{(x^2+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (np.cos(x) * (x**2 + 1) - np.sin(x) * (2*x)) / ((x**2 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine over quad plus", "metadata": {"attempts": 1, "code_length": 3626}}
{"function": "x^3 + 2*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-60, 60, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + 2*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + 2x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + 2x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 2x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 2\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic plus 2x", "metadata": {"attempts": 2, "code_length": 3480}}
{"function": "2*e^(-x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 10, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.exp(-x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2e^{-x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2e^{-x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[e^{u}] = e^{u} \\frac{du}{dx}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot e^{-x} \\cdot (-1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2e^{-x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 * np.exp(-x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled decay", "metadata": {"attempts": 1, "code_length": 3501}}
{"function": "-x/2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x/2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -\\frac{x}{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -\\frac{x}{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx] = c\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\frac{1}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -0.5\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative half linear", "metadata": {"attempts": 1, "code_length": 3460}}
{"function": "ln(ln(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(np.log(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[2.8, 3.9])\n        func_label = MathTex(r\"f(x) = \\ln(\\ln(x))\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(\\ln(x))\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(g(x))] = \\frac{g'(x)}{g(x)}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{\\ln(x)} \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x \\ln(x)}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(2.8)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (x * np.log(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.8), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "double logarithm", "metadata": {"attempts": 1, "code_length": 3520}}
{"function": "x*ln(x)*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[0.1, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.log(x) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = x \\ln(x) \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\ln(x) \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\ln(x)\\sin(x) + \\sin(x) + x\\ln(x)\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\ln(x)\\sin(x) + \\sin(x) + x\\ln(x)\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.log(x) * np.sin(x) + np.sin(x) + x * np.log(x) * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x log sine", "metadata": {"attempts": 1, "code_length": 3602}}
{"function": "2*x^2*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 100, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**2*np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^2 e^x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^2 e^x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (4x)e^x + 2x^2 e^x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2xe^x(2 + x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x*np.exp(x) + 2*x**2*np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "scaled quad exp", "metadata": {"attempts": 1, "code_length": 3500}}
{"function": "sin(5*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(5*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(5x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(5x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\sin(g(x))] = \\cos(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(5x) \\cdot 5\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 5\\cos(5x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 5 * np.cos(5*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "fifth frequency sine", "metadata": {"attempts": 1, "code_length": 3493}}
{"function": "x^6", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 15, 5], # Adjusted y_range for x^6 with limited x_range for plot\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**6\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.5, 1.5]) # Limited x_range for plot to fit y_range\n        func_label = MathTex(r\"f(x) = x^{6}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{6}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 6x^{5}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 6x^{5}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1.2) # Adjusted initial x_tracker value to fit new graph x_range\n        \n        # Define derivative function\n        def f_prime(x):\n            return 6*x**5\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.8, x_tracker.get_value()+0.8], # Adjusted tangent length\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1.2), run_time=3, rate_func=smooth) # Adjusted end x_tracker value\n        self.wait(1)", "level": "foundation", "description": "sixth power", "metadata": {"attempts": 1, "code_length": 3665}}
{"function": "0.5*sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * np.sqrt(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0, 3.5])\n        func_label = MathTex(r\"f(x) = 0.5 \\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.5 x^{1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.5 \\cdot \\frac{1}{2} x^{-1/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{4\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.25 * x**(-0.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.0), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "half square root", "metadata": {"attempts": 1, "code_length": 3514}}
{"function": "2*cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2.5, 2.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.cos(2 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2\\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2\\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot (-\\sin(2x)) \\cdot 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -4\\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -4 * np.sin(2 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled compressed cosine", "metadata": {"attempts": 1, "code_length": 3515}}
{"function": "x^2*ln(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.log(x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-0.9, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\ln(x + 1)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\ln(x + 1)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x \\ln(x+1) + x^2/(x+1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x \\ln(x+1) + \\frac{x^2}{x+1}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.1)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * x * np.log(x + 1) + (x**2) / (x + 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad shifted log", "metadata": {"attempts": 1, "code_length": 3549}}
{"function": "x^2*sin(x)*e^(-x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-30, 5, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.sin(x) * np.exp(-x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\sin(x) e^{-x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\sin(x) e^{-x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = xe^{-x}(2\\sin(x) + x\\cos(x) - x\\sin(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = xe^{-x}(2\\sin(x) + x\\cos(x) - x\\sin(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x * np.exp(-x) * (2 * np.sin(x) + x * np.cos(x) - x * np.sin(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "quad sine decay", "metadata": {"attempts": 1, "code_length": 3615}}
{"function": "3*x*e^(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 30, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3*x*np.exp(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 1.5]) # Adjusted x_range for better visibility of the curve\n        func_label = MathTex(r\"f(x) = 3xe^{2x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3xe^{2x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3e^{2x} + 3x(2e^{2x})\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3e^{2x}(1 + 2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*np.exp(2*x)*(1 + 2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1), run_time=3, rate_func=smooth) # Adjusted end value for better visibility\n        self.wait(1)", "level": "application", "description": "scaled x fast exp", "metadata": {"attempts": 2, "code_length": 3591}}
{"function": "ln(sin(x))*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-6, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            # Ensure sin(x) > 0 for ln to be defined\n            if np.sin(x) > 0:\n                return np.log(np.sin(x)) * x\n            return np.nan # Return NaN for undefined regions\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, np.pi - 0.01]) # Plot only where defined\n        func_label = MathTex(r\"f(x) = x \\ln(\\sin(x))\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\ln(\\sin(x))\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\ln(\\sin(x)) + x \\cot(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\ln(\\sin(x)) + x \\cot(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start within the defined domain\n        \n        # Define derivative function\n        def f_prime(x):\n            if np.sin(x) > 0:\n                return np.log(np.sin(x)) + x * (np.cos(x) / np.sin(x))\n            return np.nan\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2.5), run_time=3, rate_func=smooth) # Stay within defined domain\n        self.wait(1)", "level": "advanced", "description": "log sine times x", "metadata": {"attempts": 1, "code_length": 3856}}
{"function": "x^3 + 2*x^2 - 5*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 40, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + 2*x**2 - 5*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + 2x^{2} - 5x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + 2x^{2} - 5x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } (x^n)' = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 2(2x^{1}) - 5(1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 4x - 5\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 4*x - 5\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic with roots", "metadata": {"attempts": 1, "code_length": 3516}}
{"function": "3*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 50, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3 * x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3 \\cdot 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 6x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 6 * x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "triple quadratic", "metadata": {"attempts": 1, "code_length": 3456}}
{"function": "x*sin(x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.sin(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\sin(x/2)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\sin(x/2)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\sin(x/2) + \\frac{x}{2} \\cos(x/2)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\sin(x/2) + \\frac{x}{2} \\cos(x/2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.sin(x/2) + (x/2) * np.cos(x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "x stretched sine", "metadata": {"attempts": 1, "code_length": 3539}}
{"function": "2*x*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x*np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 2.5]) # Adjusted x_range for better visualization of y_range\n        func_label = MathTex(r\"f(x) = 2xe^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2xe^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2e^{x} + 2xe^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2e^{x}(1+x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*np.exp(x) + 2*x*np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled x exponential", "metadata": {"attempts": 1, "code_length": 3540}}
{"function": "e^x + e^(-x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) + np.exp(-x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} + e^{-x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} + e^{-x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^u] = e^u u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x}(1) + e^{-x}(-1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x} - e^{-x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) - np.exp(-x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "hyperbolic cosine", "metadata": {"attempts": 1, "code_length": 3497}}
{"function": "-x*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-20, 1, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -xe^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -xe^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -e^{x} - xe^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -e^{x}(1+x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.exp(x) * (1 + x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative x exponential", "metadata": {"attempts": 1, "code_length": 3478}}
{"function": "ln(x) + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x) + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x) + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(x)+x] = \\frac{1}{x}+1\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x} + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x} + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "log plus x", "metadata": {"attempts": 1, "code_length": 3472}}
{"function": "sin(2*x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(2 * x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(2x^{2})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(2x^{2})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(2x^{2}) \\cdot 4x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x \\cos(2x^{2})\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4 * x * np.cos(2 * x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine of scaled square", "metadata": {"attempts": 1, "code_length": 3521}}
{"function": "sqrt(x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 2.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0, 3.5]) # Adjusted x_range for sqrt(x/2)\n        func_label = MathTex(r\"f(x) = \\sqrt{\\frac{x}{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\left(\\frac{x}{2}\\right)^{1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } (u^n)' = nu^{n-1}u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}\\left(\\frac{x}{2}\\right)^{-1/2} \\cdot \\frac{1}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{4}\\left(\\frac{x}{2}\\right)^{-1/2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker in valid domain\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.25 * (x/2)**(-0.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.01, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure x_range for tangent is valid\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth) # Animate within valid domain\n        self.wait(1)", "level": "conceptual", "description": "root of half x", "metadata": {"attempts": 1, "code_length": 3731}}
{"function": "cos(x)*cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x) * np.cos(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x)\\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x)\\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x)\\cos(2x) - 2\\cos(x)\\sin(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\sin(x)\\cos(2x) - 2\\cos(x)\\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.sin(x) * np.cos(2*x) - 2 * np.cos(x) * np.sin(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "cosine product", "metadata": {"attempts": 1, "code_length": 3586}}
{"function": "sin(x/3)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x/3)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin\\left(\\frac{x}{3}\\right)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin\\left(\\frac{x}{3}\\right)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\sin(u)] = \\cos(u) \\cdot u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos\\left(\\frac{x}{3}\\right) \\cdot \\frac{1}{3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{3}\\cos\\left(\\frac{x}{3}\\right)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (1/3) * np.cos(x/3)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "third frequency sine", "metadata": {"attempts": 1, "code_length": 3599}}
{"function": "e^x*sin(x)/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) * np.sin(x) / x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{e^x \\sin(x)}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{e^x \\sin(x)}{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{(e^x \\sin x)' x - e^x \\sin x}{x^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{e^x(x\\sin x + x\\cos x - \\sin x)}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (x * np.sin(x) + x * np.cos(x) - np.sin(x)) / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "exp sine over x", "metadata": {"attempts": 1, "code_length": 3639}}
{"function": "x^4 - 4*x^3 + 4*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 - 4*x**3 + 4*x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} - 4x^{3} + 4x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} - 4x^{3} + 4x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} - 12x^{2} + 8x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} - 12x^{2} + 8x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 - 12*x**2 + 8*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quartic perfect 2", "metadata": {"attempts": 1, "code_length": 3545}}
{"function": "ln(x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x/2)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x/2)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"f(x) = \\ln(x) - \\ln(2)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x} - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure x_range for tangent is positive\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "log of half x", "metadata": {"attempts": 1, "code_length": 3493}}
{"function": "sin(x) - 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2.5, 0.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) - 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x) - 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x) - 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\sin(x)] = \\cos(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x) - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "shifted sine down", "metadata": {"attempts": 1, "code_length": 3461}}
{"function": "sin(x^3)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x**3)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.8, 1.8]) # Adjusted x_range for better visualization of sin(x^3)\n        func_label = MathTex(r\"f(x) = \\sin(x^{3})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x^{3})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x^{3}) \\cdot 3x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2}\\cos(x^{3})\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1.5) # Adjusted initial x_tracker value\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 * x**2 * np.cos(x**3)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.8, x_tracker.get_value()+0.8], # Adjusted tangent length\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1.5), run_time=3, rate_func=smooth) # Adjusted end x_tracker value\n        self.wait(1)", "level": "application", "description": "sine of cube", "metadata": {"attempts": 1, "code_length": 3671}}
{"function": "x + 10", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[5, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x + 10\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x + 10\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x + 10\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rules: } \\frac{d}{dx}[x]=1, \\frac{d}{dx}[c]=0\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1 + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "linear large shift", "metadata": {"attempts": 1, "code_length": 3440}}
{"function": "0.5*x^4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 50, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * x**4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 0.5x^{4}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.5x^{4}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.5 \\cdot 4x^{3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x^{3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * x**3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "half quartic", "metadata": {"attempts": 1, "code_length": 3470}}
{"function": "e^x/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) / x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{e^x}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{e^x}{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{xe^x - e^x}{x^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{e^x(x-1)}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (x - 1) / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exponential over x", "metadata": {"attempts": 3, "code_length": 3535}}
{"function": "x^5 - x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-40, 40, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**5 - x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{5} - x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{5} - x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 5x^{4} - 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 5x^{4} - 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 5*x**4 - 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quintic minus quadratic", "metadata": {"attempts": 1, "code_length": 3490}}
{"function": "x*sin(x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.sin(x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\sin(x) \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\cdot \\frac{1}{2}\\sin(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (1)\\frac{1}{2}\\sin(2x) + x(\\cos(2x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2}\\sin(2x) + x\\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.sin(2*x) + x * np.cos(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "triple product", "metadata": {"attempts": 1, "code_length": 3574}}
{"function": "0.5*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 1, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 0.5 \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.5 \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[c \\sin(x)] = c \\cos(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.5 \\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 0.5 \\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "half sine", "metadata": {"attempts": 1, "code_length": 3475}}
{"function": "sqrt(x)*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(x) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{x}\\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sqrt{x}\\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2\\sqrt{x}\\sin(x) + \\sqrt{x}\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\sin(x)}{2\\sqrt{x} + \\sqrt{x}\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * x**(-0.5) * np.sin(x) + np.sqrt(x) * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "root sine product", "metadata": {"attempts": 1, "code_length": 3602}}
{"function": "e^(cos(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(np.cos(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{\\cos(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{\\cos(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{\\cos(x)} (-\\sin(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\sin(x) e^{\\cos(x)}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.sin(x) * np.exp(np.cos(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exponential of cosine", "metadata": {"attempts": 1, "code_length": 3531}}
{"function": "0.5*x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-35, 35, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 0.5x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.5x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1.5x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1.5x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1.5 * x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "half cubic", "metadata": {"attempts": 1, "code_length": 3466}}
{"function": "x^3 + 4*x^2 + 4*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + 4*x**2 + 4*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + 4x^{2} + 4x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + 4x^{2} + 4x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 8x + 4\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 8x + 4\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 8*x + 4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic complete", "metadata": {"attempts": 1, "code_length": 3516}}
{"function": "x^2 - x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 - x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} - x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} - x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} - 1x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x - 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x - 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quadratic minus x", "metadata": {"attempts": 1, "code_length": 3467}}
{"function": "2*x^3 - 6*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-70, 70, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**3 - 6*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{3} - 6x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{3} - 6x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power/Sum Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2(3)x^{2} - 6(1)x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 6x^{2} - 6\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=00.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 6*x**2 - 6\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "scaled cubic roots", "metadata": {"attempts": 1, "code_length": 3497}}
{"function": "x*e^(-x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 1, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.exp(-x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = xe^{-x^2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = xe^{-x^2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{-x^2} - 2x^2e^{-x^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{-x^2}(1 - 2x^2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(-x**2) * (1 - 2*x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "gaussian with linear", "metadata": {"attempts": 1, "code_length": 3509}}
{"function": "sin(x)/sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.where(x > 0, np.sin(x) / np.sqrt(x), np.nan)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5]) # Start x_range slightly above 0\n        func_label = MathTex(r\"f(x) = \\frac{\\sin(x)}{\\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\sin(x)}{\\sqrt{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\sqrt{x}\\cos(x) - \\sin(x)/(2\\sqrt{x})}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2x\\cos(x) - \\sin(x)}{2x\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker at a positive value\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.where(x > 0, (2*x*np.cos(x) - np.sin(x)) / (2*x*np.sqrt(x)), np.nan)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.01, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure x_range for tangent is positive\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine over root", "metadata": {"attempts": 3, "code_length": 3803}}
{"function": "x^4*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3}e^{x} + x^{4}e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^{3}e^{x}(4+x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (4 * x**3 * np.exp(x)) + (x**4 * np.exp(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quartic exponential", "metadata": {"attempts": 1, "code_length": 3524}}
{"function": "sin(x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x^{2})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x^{2})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\sin(u)] = \\cos(u) \\cdot u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x^{2}) \\cdot 2x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x \\cos(x^{2})\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * x * np.cos(x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine of square", "metadata": {"attempts": 1, "code_length": 3516}}
{"function": "e^(-x)*sin(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-7, 7, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(-x) * np.sin(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{-x}\\sin(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{-x}\\sin(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -e^{-x}\\sin(2x) + 2e^{-x}\\cos(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{-x}(2\\cos(2x) - \\sin(2x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(-x) * (2 * np.cos(2*x) - np.sin(2*x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "decay compressed sine", "metadata": {"attempts": 1, "code_length": 3560}}
{"function": "x^2 - 5*x + 6", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 - 5*x + 6\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} - 5x + 6\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} - 5x + 6\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x - 5\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x - 5\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x - 5\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "factored form quadratic", "metadata": {"attempts": 1, "code_length": 3474}}
{"function": "0.5*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 0.5x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.5x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.5 \\cdot 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "half quadratic", "metadata": {"attempts": 1, "code_length": 3457}}
{"function": "x^3*e^(-x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 * np.exp(-x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3}e^{-x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3}e^{-x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2}e^{-x} - x^{3}e^{-x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^{2}e^{-x}(3-x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x**2 * np.exp(-x) * (3 - x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic decay", "metadata": {"attempts": 1, "code_length": 3511}}
{"function": "2*x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-90, 90, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot 3 x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 6x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 6*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled cubic", "metadata": {"attempts": 1, "code_length": 3462}}
{"function": "(x^3 - x^2)/(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return (x**3 - x**2) / (x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5], discontinuities=[-1])\n        func_label = MathTex(r\"f(x) = \\frac{x^3 - x^2}{x + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^3 - x^2}{x + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{2x^3 + 2x^2 - 2x}{(x+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2x(x^2 + x - 1)}{(x+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (2*x**3 + 2*x**2 - 2*x) / ((x + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "cubic quad over linear", "metadata": {"attempts": 1, "code_length": 3619}}
{"function": "x^2*sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 25, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**(5/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0, 3.5]) # x_range adjusted for sqrt(x)\n        func_label = MathTex(r\"f(x) = x^{2} \\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{5/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{5}{2}x^{\\frac{5}{2}-1} = \\frac{5}{2}x^{\\frac{3}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{5}{2}x^{3/2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start from a valid x for the function\n        \n        # Define derivative function\n        def f_prime(x):\n            return (5/2) * x**(3/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Adjusted x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad root", "metadata": {"attempts": 1, "code_length": 3640}}
{"function": "1/x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1/(x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{1}{x^2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{-2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2x^{-3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{2}{x^3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 * x**(-3)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "inverse square", "metadata": {"attempts": 3, "code_length": 3472}}
{"function": "x^3/e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 / np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1, 4])\n        func_label = MathTex(r\"f(x) = \\frac{x^3}{e^x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^3}{e^x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{3x^2 e^x - x^3 e^x}{(e^x)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{x^2(3-x)}{e^x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (x**2 * (3 - x)) / np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic over exp", "metadata": {"attempts": 1, "code_length": 3553}}
{"function": "e^(-2*x)*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(-2*x) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{-2x} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{-2x} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2e^{-2x}\\sin(x) + e^{-2x}\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{-2x}(\\cos(x) - 2\\sin(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(-2*x) * (np.cos(x) - 2*np.sin(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "fast decay oscillation", "metadata": {"attempts": 1, "code_length": 3559}}
{"function": "x^2*ln(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 25, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.log(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\ln(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\ln(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (2x)\\ln(2x) + x^{2}(\\frac{1}{x})\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\\ln(2x) + x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x*np.log(2*x) + x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad scaled log", "metadata": {"attempts": 1, "code_length": 3512}}
{"function": "-x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-50, 50, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -3x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -3x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -3*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative cubic", "metadata": {"attempts": 1, "code_length": 3453}}
{"function": "x^2 + x + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 18, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + x + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + x + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + x + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Sum/Power Rule}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + 1 + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "complete quadratic 1", "metadata": {"attempts": 1, "code_length": 3451}}
{"function": "-x^2 + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**2 + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{2} + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{2} + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "inverted quadratic shifted", "metadata": {"attempts": 1, "code_length": 3456}}
{"function": "e^(3*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(3*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{3x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{3x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^{ax}] = ae^{ax}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3e^{3x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3e^{3x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 * np.exp(3*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "triple rate exponential", "metadata": {"attempts": 1, "code_length": 3447}}
{"function": "sin(4*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(4*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(4x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(4x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\sin(u)] = \\cos(u)u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(4x) \\cdot 4\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4\\cos(4x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4 * np.cos(4*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "quad frequency sine", "metadata": {"attempts": 1, "code_length": 3484}}
{"function": "-sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -\\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -\\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\sin(x)] = \\cos(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = - \\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative sine", "metadata": {"attempts": 1, "code_length": 3448}}
{"function": "x^4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quartic function", "metadata": {"attempts": 1, "code_length": 3445}}
{"function": "x + 3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 7, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x + 3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x + 3\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x + 3\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[x] = 1, \\frac{d}{dx}[c] = 0\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1 + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "linear shifted up", "metadata": {"attempts": 1, "code_length": 3426}}
{"function": "x^3*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[0, 4, 1], # Adjusted x_range for ln(x)\n            y_range=[-5, 60, 10], # Adjusted y_range for x^3*ln(x)\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5]) # Adjusted x_range for ln(x)\n        func_label = MathTex(r\"f(x) = x^{3} \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2}\\ln(x) + x^{3} \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^{2}(3\\ln(x) + 1)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Adjusted start value for ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x**2 * (3 * np.log(x) + 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), min(3.5, x_tracker.get_value()+1.5)], # Adjusted x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth) # Adjusted end value for ln(x)\n        self.wait(1)", "level": "application", "description": "cubic log product", "metadata": {"attempts": 1, "code_length": 3734}}
{"function": "-ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5]) # Adjusted x_range for ln(x)\n        func_label = MathTex(r\"f(x) = -\\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -\\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[\\ln(x)] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker in domain of ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure tangent x_range is in domain\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative logarithm", "metadata": {"attempts": 1, "code_length": 3578}}
{"function": "2*ln(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.log(x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-0.9, 3.5])\n        func_label = MathTex(r\"f(x) = 2\\ln(x + 1)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2\\ln(x + 1)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[c \\ln(u)] = c \\frac{u'}{u}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot \\frac{1}{x+1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2}{x+1}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0) # Start at x=0, as function is undefined for x <= -1\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 / (x + 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled shifted log", "metadata": {"attempts": 2, "code_length": 3559}}
{"function": "e^(x - 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 25, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x - 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x-1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x-1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^{u}] = e^{u}u' \\text{ where } u=x-1\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x-1} \\cdot 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x-1}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x - 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "exponential phase shift 2", "metadata": {"attempts": 1, "code_length": 3477}}
{"function": "2*x^2 - 3*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 36, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**2 - 3*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{2} - 3x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{2} - 3x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2(2x^{1}) - 3(1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x - 3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x - 3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled quad minus linear", "metadata": {"attempts": 1, "code_length": 3476}}
{"function": "-tan(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.tan(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.5, 1.5]) # Adjusted x_range to avoid asymptotes\n        func_label = MathTex(r\"f(x) = -\\tan(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -\\tan(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[\\tan(x)] = \\sec^2(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sec^2(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\sec^2(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1) # Adjusted initial x_tracker to avoid asymptote\n        \n        # Define derivative function\n        def f_prime(x):\n            return -1 / (np.cos(x)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Adjusted tangent length\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1), run_time=3, rate_func=smooth) # Adjusted end value to avoid asymptote\n        self.wait(1)", "level": "conceptual", "description": "negative tangent", "metadata": {"attempts": 1, "code_length": 3631}}
{"function": "x^4 + x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 20, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 + x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} + x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} + x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} + 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} + 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 + 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "even powers", "metadata": {"attempts": 1, "code_length": 3488}}
{"function": "-2*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-35, 5, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -2*x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -2x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -2x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2 \\cdot 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -4x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -4*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative scaled quadratic", "metadata": {"attempts": 1, "code_length": 3458}}
{"function": "ln(x + 2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x + 2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.99, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x + 2)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x + 2)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(u)] = \\frac{1}{u} \\frac{du}{dx}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x + 2} \\cdot 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x + 2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (x + 2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "log input shifted 2", "metadata": {"attempts": 1, "code_length": 3495}}
{"function": "ln(x)/(cos(x) + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) / (np.cos(x) + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.0]) # Adjusted x_range for ln(x) domain and asymptote\n        func_label = MathTex(r\"f(x) = \\frac{\\ln(x)}{\\cos(x) + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\ln(x)}{\\cos(x) + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\frac{1}{x}(\\cos x+1) - \\ln x(-\\sin x)}{(\\cos x+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos x+1 + x\\ln x \\sin x}{x(\\cos x+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.1) # Start x_tracker within the domain (x > 0)\n        \n        # Define derivative function\n        def f_prime(x):\n            return ((1/x) * (np.cos(x) + 1) - np.log(x) * (-np.sin(x))) / (np.cos(x) + 1)**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Adjusted tangent length\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2.5), run_time=3, rate_func=smooth) # Adjusted end value to avoid asymptote\n        self.wait(1)", "level": "advanced", "description": "log over cosine plus", "metadata": {"attempts": 1, "code_length": 3845}}
{"function": "tan(ln(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.tan(np.log(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\tan(\\ln(x))\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\tan(\\ln(x))\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } (f(g(x)))' = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\sec^2(\\ln(x)) \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\sec^2(\\ln(x))}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (x * (np.cos(np.log(x)))**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "tangent of log", "metadata": {"attempts": 1, "code_length": 3541}}
{"function": "x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.15, 2.15]) # Adjusted x_range for better fit within y_range\n        func_label = MathTex(r\"f(x) = x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "basic cubic", "metadata": {"attempts": 1, "code_length": 3497}}
{"function": "x^2*e^(-x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.1, 0.5, 0.1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.exp(-x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} e^{-x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} e^{-x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2xe^{-x^{2} - 2x^{3}e^{-x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2xe^{-x^{2}(1 - x^{2})\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * x * np.exp(-x**2) * (1 - x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "gaussian with quadratic", "metadata": {"attempts": 2, "code_length": 3544}}
{"function": "x*sin(x)*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.sin(x) * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = x \\sin(x) \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\sin(x) \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (\\sin(x) + x\\cos(x))\\ln(x) + \\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\sin(x)(\\ln(x)+1) + x\\cos(x)\\ln(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.sin(x) * (np.log(x) + 1) + x * np.cos(x) * np.log(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), min(3.5, x_tracker.get_value()+1.5)],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.0), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "x sine log", "metadata": {"attempts": 1, "code_length": 3607}}
{"function": "sin(x)*cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) * np.cos(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x)\\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x)\\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x)\\cos(2x) - 2\\sin(x)\\sin(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x)\\cos(2x) - 2\\sin(x)\\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x) * np.cos(2*x) - 2 * np.sin(x) * np.sin(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine cosine different freq", "metadata": {"attempts": 1, "code_length": 3581}}
{"function": "e^x/(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) / (x**2 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{e^x}{x^2 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{e^x}{x^2 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{e^x(x^2+1) - e^x(2x)}{(x^2+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{e^x(x-1)^2}{(x^2+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (np.exp(x) * (x**2 + 1) - np.exp(x) * (2*x)) / ((x**2 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp over quad plus", "metadata": {"attempts": 1, "code_length": 3613}}
{"function": "x/ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            if x <= 0 or x == 1: # Handle domain issues for ln(x)\n                return np.nan\n            return x / np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x}{\\ln(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x}{\\ln(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\ln(x) - 1}{(\\ln(x))^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\ln(x) - 1}{(\\ln(x))^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.2) # Start tracker in valid domain\n        \n        # Define derivative function\n        def f_prime(x):\n            if x <= 0 or x == 1: # Handle domain issues for ln(x)\n                return np.nan\n            return (np.log(x) - 1) / (np.log(x))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.0), run_time=3, rate_func=smooth) # Animate within valid domain\n        self.wait(1)", "level": "application", "description": "x over log", "metadata": {"attempts": 1, "code_length": 3817}}
{"function": "x^4 + x^2 + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 25, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 + x**2 + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} + x^{2} + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} + x^{2} + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} + 2x^{1} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} + 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 + 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quartic complete", "metadata": {"attempts": 1, "code_length": 3504}}
{"function": "x^4 + 4*x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-30, 50, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 + 4*x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 2.5]) # Adjusted x_range for better visibility within y_range\n        func_label = MathTex(r\"f(x) = x^{4} + 4x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} + 4x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} + 4(3x^{2})\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} + 12x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 + 12*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quartic cubic mix", "metadata": {"attempts": 1, "code_length": 3562}}
{"function": "2*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 35, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled quadratic", "metadata": {"attempts": 1, "code_length": 3450}}
{"function": "x*sin(x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.sin(x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\sin(x) \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\sin(x) \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\sin(x)\\cos(x) + x(\\cos^2(x) - \\sin^2(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2}\\sin(2x) + x\\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.sin(2*x) + x * np.cos(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "x sine cosine", "metadata": {"attempts": 1, "code_length": 3569}}
{"function": "0.5*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = 0.5 \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.5 \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[c \\ln(x)] = \\frac{c}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.5 \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{0.5}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 / x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "half logarithm", "metadata": {"attempts": 1, "code_length": 3486}}
{"function": "x*cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.cos(2 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(2x) + x(-2\\sin(2x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(2x) - 2x\\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(2 * x) - 2 * x * np.sin(2 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "linear compressed cosine", "metadata": {"attempts": 1, "code_length": 3522}}
{"function": "e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^x] = e^x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "exponential function", "metadata": {"attempts": 1, "code_length": 3425}}
{"function": "-2*x^5", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -2 * x**5\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -2x^{5}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -2x^{5}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2 \\cdot 5x^{4}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -10x^{4}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -10 * x**4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative scaled quintic", "metadata": {"attempts": 1, "code_length": 3472}}
{"function": "2*sin(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.sin(2 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2\\sin(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2\\sin(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2\\cos(2x) \\cdot 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4\\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4 * np.cos(2 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled compressed sine", "metadata": {"attempts": 1, "code_length": 3499}}
{"function": "x^5 + 5*x^3 + 4*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**5 + 5*x**3 + 4*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.5, 1.5]) # Adjusted x_range for better visualization\n        func_label = MathTex(r\"f(x) = x^{5} + 5x^{3} + 4x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{5} + 5x^{3} + 4x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 5x^{4} + 15x^{2} + 4\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 5x^{4} + 15x^{2} + 4\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1) # Adjusted initial x_tracker value\n        \n        # Define derivative function\n        def f_prime(x):\n            return 5*x**4 + 15*x**2 + 4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Adjusted tangent length\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1), run_time=3, rate_func=smooth) # Adjusted x_tracker end value\n        self.wait(1)", "level": "foundation", "description": "quintic expanded", "metadata": {"attempts": 1, "code_length": 3667}}
{"function": "x^3 - x*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-40, 40, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - x * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - x \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - x \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rules: Power, Product}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - (\\cos(x) - x\\sin(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - \\cos(x) + x\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 * x**2 - np.cos(x) + x * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic minus x cosine", "metadata": {"attempts": 1, "code_length": 3541}}
{"function": "cos(5*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(5*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(5x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(5x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\cos(ax)] = -a\\sin(ax)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(5x) \\cdot 5\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -5\\sin(5x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -5 * np.sin(5*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Adjusted range for better visibility with high frequency\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "fifth frequency cosine", "metadata": {"attempts": 1, "code_length": 3534}}
{"function": "x*e^(-x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.exp(-x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x e^{-x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x e^{-x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{-x} - x e^{-x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{-x}(1-x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(-x) * (1 - x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "x decay", "metadata": {"attempts": 1, "code_length": 3481}}
{"function": "sin(x)/(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) / (x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\sin(x)}{x + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\sin(x)}{x + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{(x+1)\\cos(x) - \\sin(x)}{(x+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{(x+1)\\cos(x) - \\sin(x)}{(x+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (np.cos(x) * (x + 1) - np.sin(x)) / ((x + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine over linear", "metadata": {"attempts": 1, "code_length": 3610}}
{"function": "(sin(x) + cos(x))/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return (np.sin(x) + np.cos(x)) / x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\sin(x) + \\cos(x)}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\sin(x) + \\cos(x)}{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{x(\\cos x - \\sin x) - (\\sin x + \\cos x)}{x^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{(x-1)\\cos x - (x+1)\\sin x}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (x * np.cos(x) - x * np.sin(x) - np.sin(x) - np.cos(x)) / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "trig sum over x", "metadata": {"attempts": 3, "code_length": 3657}}
{"function": "-x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative quadratic", "metadata": {"attempts": 1, "code_length": 3446}}
{"function": "x^2*tan(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.tan(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.5, 1.5]) # Adjusted x_range to avoid asymptotes for better visualization\n        func_label = MathTex(r\"f(x) = x^{2} \\tan(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\tan(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x \\tan(x) + x^{2} \\sec^{2}(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x \\tan(x) + x^{2} \\sec^{2}(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x * np.tan(x) + x**2 * (1/np.cos(x))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Adjusted x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad tangent product", "metadata": {"attempts": 1, "code_length": 3643}}
{"function": "x^4*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3}\\ln(x) + x^{4} \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^{3}(4\\ln(x) + 1)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4 * x**3 * np.log(x) + x**3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2.5), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quartic log", "metadata": {"attempts": 1, "code_length": 3539}}
{"function": "3*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-12, 12, 3],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3 \\cdot 1x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "triple linear", "metadata": {"attempts": 1, "code_length": 3419}}
{"function": "x^3/2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-20, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 / 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{1}{2}x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{1}{2}x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2} \\cdot 3x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{3}{2}x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3/2 * x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic divided", "metadata": {"attempts": 1, "code_length": 3506}}
{"function": "x^2 + e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 50, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rules: } (x^n)'=nx^{n-1}, (e^x)'=e^x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x + e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x + np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad plus exp", "metadata": {"attempts": 1, "code_length": 3488}}
{"function": "e^x*sin(x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) * np.sin(x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} \\sin(x^{2})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} \\sin(x^{2})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x}\\sin(x^{2}) + e^{x}(2x\\cos(x^{2}))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}(\\sin(x^{2}) + 2x\\cos(x^{2}))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * np.sin(x**2) + np.exp(x) * (2 * x * np.cos(x**2))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "exp sine square", "metadata": {"attempts": 1, "code_length": 3597}}
{"function": "1.5*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 60, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1.5 * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 1.5e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 1.5e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[e^x] = e^x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1.5e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1.5e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1.5 * np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "one-half exponential", "metadata": {"attempts": 1, "code_length": 3464}}
{"function": "x*e^x*cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.exp(x) * np.cos(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.5, 2.5])\n        func_label = MathTex(r\"f(x) = xe^x \\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = xe^x \\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uvw)' = u'vw + uv'w + uvw'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^x\\cos(2x) + xe^x\\cos(2x) - 2xe^x\\sin(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^x((1+x)\\cos(2x) - 2x\\sin(2x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (np.cos(2*x) + x*np.cos(2*x) - 2*x*np.sin(2*x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "x exp compressed cosine", "metadata": {"attempts": 1, "code_length": 3600}}
{"function": "2*x + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-8, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[ax+b] = a\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2(1) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled linear with constant", "metadata": {"attempts": 1, "code_length": 3416}}
{"function": "x^2/ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            if x <= 0 or np.isclose(x, 1): # Handle domain and asymptote\n                return np.nan\n            return x**2 / np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x^2}{\\ln(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^2}{\\ln(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{2x\\ln(x) - x}{(\\ln(x))^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{x(2\\ln(x) - 1)}{(\\ln(x))^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            if x <= 0 or np.isclose(x, 1): # Handle domain and asymptote\n                return np.nan\n            return (2*x*np.log(x) - x) / (np.log(x))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad over log", "metadata": {"attempts": 1, "code_length": 3784}}
{"function": "x^4 - 3*x^2 + 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 7, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 - 3*x**2 + 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} - 3x^{2} + 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} - 3x^{2} + 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} - 3(2x^{1}) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} - 6x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 - 6*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quartic two pairs", "metadata": {"attempts": 2, "code_length": 3510}}
{"function": "ln(x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-8, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x^{2})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x^{2})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(g(x))] = \\frac{g'(x)}{g(x)}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{2x}{x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "logarithm composition", "metadata": {"attempts": 2, "code_length": 3469}}
{"function": "x^2 - 4*x + 4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 - 4*x + 4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} - 4x + 4\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} - 4x + 4\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x - 4\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x - 4\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x - 4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "perfect square", "metadata": {"attempts": 1, "code_length": 3474}}
{"function": "-x^3 + 2*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**3 + 2*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{3} + 2x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{3} + 2x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -3x^{2} + 2x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -3x^{2} + 2\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -3*x**2 + 2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative cubic linear", "metadata": {"attempts": 1, "code_length": 3485}}
{"function": "cos(x) + ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x) + np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5]) # Adjusted x_range for ln(x)\n        func_label = MathTex(r\"f(x) = \\cos(x) + \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x) + \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Sum Rule: } (u+v)' = u'+v'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x) + \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\sin(x) + \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=00.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.1) # Start x_tracker at a positive value for ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.sin(x) + 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.01, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure x_range for tangent is positive\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cosine plus log", "metadata": {"attempts": 1, "code_length": 3642}}
{"function": "x/tan(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 2], # Adjusted y-range to capture some behavior, will clip extreme values\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            # Handle x=0 case where tan(x) is 0, limit is 1\n            if np.isclose(x, 0):\n                return 1.0\n            # Handle cases where tan(x) is undefined (x = pi/2 + n*pi)\n            if np.isclose(np.cos(x), 0):\n                return np.nan\n            return x / np.tan(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5], discontinuities=[n * np.pi for n in range(-1, 2)]) # Add discontinuities for better plotting\n        func_label = MathTex(r\"f(x) = \\frac{x}{\\tan(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x}{\\tan(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\tan(x) - x\\sec^2(x)}{\\tan^2(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\tan(x) - x\\sec^2(x)}{\\tan^2(x)}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            if np.isclose(x, 0):\n                return 0.0 # Limit of derivative as x->0 is 0\n            sin_x = np.sin(x)\n            if np.isclose(sin_x, 0): # Handles x=n*pi\n                return np.nan\n            cos_x = np.cos(x)\n            if np.isclose(cos_x, 0): # Handles x=pi/2 + n*pi\n                return np.nan\n            # Using f'(x) = (tan(x) - x*sec^2(x)) / tan^2(x)\n            tan_x = np.tan(x)\n            sec_x_sq = 1 / (cos_x**2)\n            return (tan_x - x * sec_x_sq) / (tan_x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x over tangent", "metadata": {"attempts": 1, "code_length": 4469}}
{"function": "e^(e^x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 12, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(np.exp(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{e^x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{e^x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{e^x} \\cdot e^x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x} e^{e^x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * np.exp(np.exp(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "double exponential", "metadata": {"attempts": 1, "code_length": 3511}}
{"function": "x^3 - 2*x^2 + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-75, 25, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 2*x**2 + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 2x^{2} + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 2x^{2} + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 4x^{1} + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 4x + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 4*x + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic factored 2", "metadata": {"attempts": 1, "code_length": 3518}}
{"function": "e^(x)*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 45, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            if x <= 0:\n                return np.nan\n            return np.exp(x) * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x} \\ln(x) + e^{x} \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x} (\\ln(x) + \\frac{1}{x})\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker in valid domain\n        \n        # Define derivative function\n        def f_prime(x):\n            if x <= 0:\n                return np.nan\n            return np.exp(x) * np.log(x) + np.exp(x) * (1/x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.01, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure x_range for tangent is valid\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp log product", "metadata": {"attempts": 1, "code_length": 3740}}
{"function": "ln(x) - 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) - 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5]) # Adjusted x_range for ln(x)\n        func_label = MathTex(r\"f(x) = \\ln(x) - 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x) - 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(x)] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x} - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Adjusted start value for ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Adjusted end value for ln(x)\n        self.wait(1)", "level": "conceptual", "description": "log shifted down", "metadata": {"attempts": 1, "code_length": 3553}}
{"function": "x^3*sin(x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-25, 25, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 * np.sin(x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} \\sin(x) \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} \\sin(x) \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^2 \\sin x \\cos x + x^3(\\cos^2 x - \\sin^2 x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{3}{2}x^2 \\sin(2x) + x^3 \\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (3/2) * x**2 * np.sin(2*x) + x**3 * np.cos(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "cubic sine cosine", "metadata": {"attempts": 1, "code_length": 3605}}
{"function": "sin(e^x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(np.exp(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(e^{x})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(e^{x})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(e^{x}) \\cdot e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}\\cos(e^{x})\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * np.cos(np.exp(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine of exponential", "metadata": {"attempts": 1, "code_length": 3528}}
{"function": "x^3 + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-35, 35, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic with linear", "metadata": {"attempts": 1, "code_length": 3470}}
{"function": "e^x - 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) - 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} - 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} - 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^x] = e^x, \\frac{d}{dx}[c] = 0\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x} - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "exponential shifted down", "metadata": {"attempts": 1, "code_length": 3462}}
{"function": "x^5 + x^3 + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-60, 60, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**5 + x**3 + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.5, 2.5])\n        func_label = MathTex(r\"f(x) = x^{5} + x^{3} + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{5} + x^{3} + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 5x^{4} + 3x^{2} + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 5x^{4} + 3x^{2} + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 5*x**4 + 3*x**2 + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.8, x_tracker.get_value()+0.8], # Adjusted range for steeper curve\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quintic odd powers", "metadata": {"attempts": 1, "code_length": 3556}}
{"function": "-x^3 + 6*x^2 - 9*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 55, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**3 + 6*x**2 - 9*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{3} + 6x^{2} - 9x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{3} + 6x^{2} - 9x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -3x^{2} + 12x - 9\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -3x^{2} + 12x - 9\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -3*x**2 + 12*x - 9\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "negative cubic crit", "metadata": {"attempts": 1, "code_length": 3526}}
{"function": "2*x^3 - 9*x^2 + 12*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**3 - 9*x**2 + 12*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{3} - 9x^{2} + 12x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{3} - 9x^{2} + 12x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 6x^{2} - 18x + 12\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 6x^{2} - 18x + 12\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 6*x**2 - 18*x + 12\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "scaled cubic opt", "metadata": {"attempts": 1, "code_length": 3530}}
{"function": "x*cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.cos(2 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(2x) - 2x\\sin(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(2x) - 2x\\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(2 * x) - 2 * x * np.sin(2 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "x cosine compressed", "metadata": {"attempts": 1, "code_length": 3519}}
{"function": "tan(x) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.tan(x) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\tan(x) + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\tan(x) + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\tan(x)] = \\sec^2(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\sec^2(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\sec^2(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (np.cos(x)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "shifted tangent", "metadata": {"attempts": 2, "code_length": 3470}}
{"function": "2/x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 / (x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{2}{x^2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{-2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2(-2)x^{-3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{4}{x^3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -4 / (x**3)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled inverse square", "metadata": {"attempts": 2, "code_length": 3480}}
{"function": "cos(x/3)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x/3)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x/3)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x/3)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\cos(u)] = -\\sin(u)u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x/3) \\cdot \\frac{1}{3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{3}\\sin(x/3)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return - (1/3) * np.sin(x/3)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "third frequency cosine", "metadata": {"attempts": 1, "code_length": 3521}}
{"function": "e^(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 20, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x+1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x+1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^u] = e^u u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x+1} \\cdot 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x+1}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x + 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "exponential phase shift", "metadata": {"attempts": 1, "code_length": 3453}}
{"function": "cos(x)/sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x) / np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\cos(x)}{\\sin(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\cos(x)}{\\sin(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\frac{u}{v}] = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{-\\sin^2(x) - \\cos^2(x)}{\\sin^2(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{\\sin^2(x)}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -1 / (np.sin(x)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cotangent", "metadata": {"attempts": 1, "code_length": 3559}}
{"function": "(x^3 + 1)/(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return (x**3 + 1) / (x**2 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x^3 + 1}{x^2 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^3 + 1}{x^2 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{3x^2(x^2+1) - (x^3+1)2x}{(x^2+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{x^4 + 3x^2 - 2x}{(x^2 + 1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (x**4 + 3*x**2 - 2*x) / (x**2 + 1)**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "cubic over quadratic 2", "metadata": {"attempts": 1, "code_length": 3607}}
{"function": "0.25*x^4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 45, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.25 * x**4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 0.25x^{4}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.25x^{4}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.25 \\cdot 4x^{3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^{3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x**3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quarter quartic", "metadata": {"attempts": 1, "code_length": 3469}}
{"function": "-e^(-x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.exp(-x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -e^{-x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -e^{-x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -e^{-x} \\cdot (-1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{-x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(-x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative decay", "metadata": {"attempts": 1, "code_length": 3480}}
{"function": "x^2*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x \\sin(x) + x^{2} \\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x \\sin(x) + x^{2} \\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * x * np.sin(x) + x**2 * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "quadratic times sine", "metadata": {"attempts": 1, "code_length": 3533}}
{"function": "-e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-55, 5, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^x] = e^x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative exponential", "metadata": {"attempts": 1, "code_length": 3433}}
{"function": "e^(x^2)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x**2) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x^2} \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x^2} \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2xe^{x^2}\\cos(x) - e^{x^2}\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x^2}(2x\\cos(x) - \\sin(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x**2) * (2*x*np.cos(x) - np.sin(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "exp square cosine", "metadata": {"attempts": 1, "code_length": 3562}}
{"function": "x^4 - x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 - x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.5, 2.5]) # Adjusted x_range for better y_range fit\n        func_label = MathTex(r\"f(x) = x^{4} - x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} - x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} - 3x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} - 3x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 - 3*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quartic minus cubic", "metadata": {"attempts": 1, "code_length": 3537}}
{"function": "sin(x/2) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 2.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x/2) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x/2) + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x/2) + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x/2) \\cdot \\frac{1}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2}\\cos(x/2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.cos(x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "stretched sine shifted", "metadata": {"attempts": 1, "code_length": 3527}}
{"function": "x*sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**(3/2) if x >= 0 else np.nan\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0, 3.5]) # Adjusted x_range for sqrt(x)\n        func_label = MathTex(r\"f(x) = x \\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{3}{2}x^{1/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{3}{2}\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start from a positive value for sqrt(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (3/2) * np.sqrt(x) if x >= 0 else np.nan\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Adjusted x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Adjusted end value\n        self.wait(1)", "level": "conceptual", "description": "x times root", "metadata": {"attempts": 1, "code_length": 3668}}
{"function": "ln(x^2 + 2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x**2 + 2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x^{2} + 2)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x^{2} + 2)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\ln(u)] = \\frac{1}{u} \\frac{du}{dx}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x^{2} + 2} \\cdot 2x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2x}{x^{2} + 2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * x / (x**2 + 2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "log of quad plus 2", "metadata": {"attempts": 1, "code_length": 3541}}
{"function": "x^4 - 2*x^2 + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 - 2*x**2 + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} - 2x^{2} + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} - 2x^{2} + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} - 4x^{1} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} - 4x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 - 4*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quartic perfect", "metadata": {"attempts": 1, "code_length": 3508}}
{"function": "e^(x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 50, 10], # Adjusted y_range for e^(x^2)\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.2, 2.2]) # Adjusted x_range for plotting to fit y_range\n        func_label = MathTex(r\"f(x) = e^{x^2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x^2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } (f(g(x)))' = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x^2} \\cdot 2x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2xe^{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1.5) # Adjusted initial x_tracker value to stay within visible y_range\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * x * np.exp(x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.8, x_tracker.get_value()+0.8], # Adjusted tangent length\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1.5), run_time=3, rate_func=smooth) # Adjusted x_tracker end value\n        self.wait(1)", "level": "application", "description": "exp of square", "metadata": {"attempts": 1, "code_length": 3688}}
{"function": "3*x^2 + 2*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 60, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3*x**2 + 2*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3x^{2} + 2x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3x^{2} + 2x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3(2x) + 2(1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 6x + 2\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 6*x + 2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "triple quadratic linear", "metadata": {"attempts": 1, "code_length": 3472}}
{"function": "e^(0.5*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 8, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(0.5 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{0.5x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{0.5x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^{ax}] = ae^{ax}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.5e^{0.5x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 0.5e^{0.5x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.exp(0.5 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "half rate exponential", "metadata": {"attempts": 1, "code_length": 3468}}
{"function": "cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\cos(x)] = -\\sin(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "cosine function", "metadata": {"attempts": 1, "code_length": 3445}}
{"function": "x^3 - 12*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-20, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 12*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 12x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 12x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 12\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 12\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 12\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic simple roots", "metadata": {"attempts": 1, "code_length": 3480}}
{"function": "x^2*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x \\sin(x) + x^{2} \\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x \\sin(x) + x^{2} \\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x*np.sin(x) + (x**2)*np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quadratic sine product", "metadata": {"attempts": 1, "code_length": 3530}}
{"function": "x^3 - x^2 - x + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - x**2 - x + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - x^{2} - x + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - x^{2} - x + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 2x^{1} - 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 2x - 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 2*x - 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic factored", "metadata": {"attempts": 1, "code_length": 3525}}
{"function": "e^(x^3)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 50, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x**3)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 1.6]) # Adjusted x_range for better visibility given y_range\n        func_label = MathTex(r\"f(x) = e^{x^3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x^3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[e^{u}] = e^{u} u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x^3} \\cdot 3x^2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^2 e^{x^3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 * x**2 * np.exp(x**3)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Adjusted tangent length\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1.5), run_time=3, rate_func=smooth) # Adjusted x_tracker end value to stay on screen\n        self.wait(1)", "level": "application", "description": "exp of cube", "metadata": {"attempts": 1, "code_length": 3626}}
{"function": "-2/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -2/x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -\\frac{2}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -\\frac{2}{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2(-1)x^{-2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative scaled reciprocal", "metadata": {"attempts": 1, "code_length": 3475}}
{"function": "x^4 + x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 30, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 + x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} + x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} + x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} + 3x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} + 3x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 + 3*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quartic cubic combo", "metadata": {"attempts": 1, "code_length": 3495}}
{"function": "x/cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x / np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x}{\\cos(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x}{\\cos(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\cos(x) + x\\sin(x)}{\\cos^2(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos(x) + x\\sin(x)}{\\cos^2(x)}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (np.cos(x) + x * np.sin(x)) / (np.cos(x)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x over cosine", "metadata": {"attempts": 1, "code_length": 3590}}
{"function": "x^2*sin(x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-7, 7, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.sin(x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\sin(x) \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\sin(x) \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[uvw] = u'vw + uv'w + uvw'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = x\\sin(2x) + x^{2}\\cos(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x\\sin(2x) + x^{2}\\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x * np.sin(2*x) + (x**2) * np.cos(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad sine cosine", "metadata": {"attempts": 1, "code_length": 3560}}
{"function": "x^2 + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "shifted quadratic", "metadata": {"attempts": 1, "code_length": 3454}}
{"function": "sin(x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x/2)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x/2)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\sin(u)] = \\cos(u)u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x/2) \\cdot (1/2)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2}\\cos(x/2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.cos(x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "stretched sine", "metadata": {"attempts": 1, "code_length": 3504}}
{"function": "2*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 20, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[ce^x] = ce^x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled exponential", "metadata": {"attempts": 1, "code_length": 3439}}
{"function": "x^2*cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.cos(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x\\cos(2x) - 2x^{2}\\sin(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\\cos(2x) - 2x^{2}\\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x*np.cos(2*x) - 2*x**2*np.sin(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad compressed cosine", "metadata": {"attempts": 1, "code_length": 3541}}
{"function": "2*sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.sqrt(x) if x >= 0 else np.nan\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5]) # Adjusted x_range to avoid sqrt(negative)\n        func_label = MathTex(r\"f(x) = 2\\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot \\frac{1}{2} x^{-1/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.1) # Adjusted start value to be positive\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / np.sqrt(x) if x > 0 else np.nan # Handle division by zero and negative x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Adjusted end value\n        self.wait(1)", "level": "conceptual", "description": "scaled square root", "metadata": {"attempts": 1, "code_length": 3689}}
{"function": "x - 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x - 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x - 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x - 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rules: } \\frac{d}{dx}[x] = 1, \\frac{d}{dx}[c] = 0\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1 - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "linear shifted down", "metadata": {"attempts": 1, "code_length": 3441}}
{"function": "(x^4 - 1)/(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 - 1 # Simplified form for plotting\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x^4 - 1}{x^2 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^4 - 1}{x^2 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Simplify: } f(x) = x^2 - 1\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{d}{dx}[x^2 - 1] = 2x - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "quartic over quad plus", "metadata": {"attempts": 1, "code_length": 3517}}
{"function": "2*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2\\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2\\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Const. Mult. Rule: } (cf)' = cf'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot \\frac{d}{dx}[\\sin(x)]\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled sine", "metadata": {"attempts": 1, "code_length": 3481}}
{"function": "2/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2/x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{2}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{-1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2x^{-2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{2}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled reciprocal", "metadata": {"attempts": 2, "code_length": 3468}}
{"function": "-2*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2.5, 2.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -2 * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -2\\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -2\\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\cos(x)] = -\\sin(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2(-\\sin(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative scaled cosine", "metadata": {"attempts": 1, "code_length": 3465}}
{"function": "-3*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -3*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -3x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -3x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[cx] = c\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -3\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative triple linear", "metadata": {"attempts": 1, "code_length": 3416}}
{"function": "-2*x^2 + 4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -2*x**2 + 4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -2x^{2} + 4\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -2x^{2} + 4\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2(2)x^{1} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -4x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -4*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "inverted scaled quadratic", "metadata": {"attempts": 1, "code_length": 3469}}
{"function": "cos(3*x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(3 * x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(3x^{2})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(3x^{2})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\cos(u)] = -\\sin(u)u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(3x^{2}) \\cdot (6x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -6x \\sin(3x^{2})\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -6 * x * np.sin(3 * x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cosine triple square", "metadata": {"attempts": 1, "code_length": 3523}}
{"function": "e^x*ln(x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-40, 5, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) * np.log(x) * np.cos(x) if x > 0.01 else np.nan\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} \\ln(x) \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} \\ln(x) \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[uvw] = u'vw + uv'w + uvw'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^x(\\ln x \\cos x + \\frac{\\cos x}{x} - \\ln x \\sin x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^x(\\ln x \\cos x + \\frac{\\cos x}{x} - \\ln x \\sin x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker in valid domain\n        \n        # Define derivative function\n        def f_prime(x):\n            return (np.exp(x) * (np.log(x) * np.cos(x) + (1/x) * np.cos(x) - np.log(x) * np.sin(x))) if x > 0.01 else np.nan\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.01, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Adjust x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Animate within valid domain\n        self.wait(1)", "level": "advanced", "description": "exp log cosine", "metadata": {"attempts": 1, "code_length": 3813}}
{"function": "x^4 - 2*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 - 2*x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} - 2x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} - 2x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} - 4x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} - 4x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 - 4*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quartic minus 2x squared", "metadata": {"attempts": 1, "code_length": 3491}}
{"function": "3*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3 * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^x] = e^x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 * np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "triple exponential", "metadata": {"attempts": 1, "code_length": 3437}}
{"function": "cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } (\\cos(u))' = -\\sin(u)u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(2x) \\cdot 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2\\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 * np.sin(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "compressed cosine", "metadata": {"attempts": 1, "code_length": 3477}}
{"function": "-sin(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.sin(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -\\sin(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -\\sin(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[-\\sin(u)] = -\\cos(u) \\cdot u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\cos(2x) \\cdot 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2\\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2*np.cos(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative compressed sine", "metadata": {"attempts": 1, "code_length": 3477}}
{"function": "-2*x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-20, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -2*x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -2x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -2x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2 \\cdot 3 x^{3-1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -6x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -6*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative scaled cubic", "metadata": {"attempts": 1, "code_length": 3463}}
{"function": "2/(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 / (x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{2}{x + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{2}{x + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[g(x)^n] = n g(x)^{n-1} g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2(x+1)^{-2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{2}{(x+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 / ((x + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled shifted reciprocal", "metadata": {"attempts": 2, "code_length": 3513}}
{"function": "2*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-8, 8, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[cx] = c\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled linear", "metadata": {"attempts": 1, "code_length": 3408}}
{"function": "1.5*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-7, 7, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1.5 * x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 1.5x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 1.5x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[cx] = c\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1.5\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1.5\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1.5\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "one and half linear", "metadata": {"attempts": 1, "code_length": 3408}}
{"function": "tan(x)/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.tan(x) / x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\tan(x)}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\tan(x)}{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{x \\sec^2(x) - \\tan(x)}{x^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{x \\sec^2(x) - \\tan(x)}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (x * (1 / np.cos(x))**2 - np.tan(x)) / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "tangent over x", "metadata": {"attempts": 3, "code_length": 3585}}
{"function": "sin(x) + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x) + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x) + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rules: } \\frac{d}{dx}[\\sin(x)]=\\cos(x), \\frac{d}{dx}[x]=1\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x) + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x) + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x) + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine plus x", "metadata": {"attempts": 1, "code_length": 3497}}
{"function": "x^2*e^(sin(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.exp(np.sin(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} e^{\\sin(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} e^{\\sin(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2xe^{\\sin(x)} + x^{2}e^{\\sin(x)}\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{\\sin(x)}(2x + x^{2}\\cos(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x * np.exp(np.sin(x)) + x**2 * np.exp(np.sin(x)) * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "quad exp sine nested", "metadata": {"attempts": 1, "code_length": 3593}}
{"function": "1/(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1 / (x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{1}{x+1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = (x+1)^{-1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[u^n] = nu^{n-1}u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -1(x+1)^{-2} \\cdot 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{(x+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -1 / ((x + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "shifted reciprocal", "metadata": {"attempts": 1, "code_length": 3497}}
{"function": "x^2/(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.2, 1.2, 0.2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 / (x**2 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x^2}{x^2 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^2}{x^2 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{2x(x^2+1) - x^2(2x)}{(x^2+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2x}{(x^2+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (2*x) / ((x**2 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "bounded rational", "metadata": {"attempts": 2, "code_length": 3566}}
{"function": "x*tan(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.tan(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\tan(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\tan(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\tan(x) + x \\sec^2(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\tan(x) + x \\sec^2(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.tan(x) + x * (1 / np.cos(x))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "x times tangent", "metadata": {"attempts": 1, "code_length": 3510}}
{"function": "x*sin(x)*cos(x)*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 40, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.sin(x) * np.cos(x) * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\sin(x) \\cos(x) e^x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\sin(x) \\cos(x) e^x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^x(\\sin(2x) + x\\cos(2x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^x(\\sin(2x) + x\\cos(2x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (np.sin(2*x) + x * np.cos(2*x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "quad product advanced", "metadata": {"attempts": 1, "code_length": 3577}}
{"function": "sin(x)^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 1.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x)**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin^2(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin^2(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2\\sin(x)\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\\sin(x)\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.sin(x) * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine squared", "metadata": {"attempts": 1, "code_length": 3512}}
{"function": "x^5/2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * x**5\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.5, 2.5])\n        func_label = MathTex(r\"f(x) = \\frac{1}{2}x^5\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{1}{2}x^5\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2} \\cdot 5x^{4}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{5}{2}x^4\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (5/2) * x**4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quintic divided", "metadata": {"attempts": 1, "code_length": 3504}}
{"function": "e^x/(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) / (x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{e^x}{x + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{e^x}{x + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{e^x(x+1) - e^x}{(x+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{xe^x}{(x+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x * np.exp(x) / ((x + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp over linear", "metadata": {"attempts": 2, "code_length": 3557}}
{"function": "x^3*ln(x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 5, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            # Handle domain for ln(x)\n            if x <= 0:\n                return np.nan\n            return x**3 * np.log(x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3}\\ln(x)\\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3}\\ln(x)\\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Prod. Rule: } (uvw)' = u'vw + uv'w + uvw'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = x^2(3\\ln x \\cos x + \\cos x - x\\ln x \\sin x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^2(3\\ln x \\cos x + \\cos x - x\\ln x \\sin x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker in valid domain for ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            if x <= 0:\n                return np.nan\n            return 3 * x**2 * np.log(x) * np.cos(x) + x**2 * np.cos(x) - x**3 * np.log(x) * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure tangent x_range is valid\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2.5), run_time=3, rate_func=smooth) # Animate within valid domain\n        self.wait(1)", "level": "advanced", "description": "cubic log cosine", "metadata": {"attempts": 1, "code_length": 3908}}
{"function": "1/sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1 / np.sqrt(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{1}{\\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{-1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\frac{1}{2}x^{-3/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{2x\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -0.5 * x**(-1.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "reciprocal square root", "metadata": {"attempts": 1, "code_length": 3506}}
{"function": "3*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-8, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3 * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = 3\\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3\\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(x)] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3 \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{3}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 / x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "triple logarithm", "metadata": {"attempts": 1, "code_length": 3460}}
{"function": "-2*x^4 + 4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-30, 5, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -2*x**4 + 4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -2x^{4} + 4\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -2x^{4} + 4\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2(4)x^{3} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -8x^{3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -8*x**3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "inverted quartic", "metadata": {"attempts": 1, "code_length": 3474}}
{"function": "sin(2*x) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(2*x) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(2x) + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(2x) + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } (f(g(x)))' = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(2x) \\cdot 2 + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.cos(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "compressed sine shifted", "metadata": {"attempts": 1, "code_length": 3495}}
{"function": "2*x^3 - x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**3 - x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{3} - x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{3} - x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2(3x^{2}) - 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 6x^{2} - 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 6*x**2 - 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled cubic minus x", "metadata": {"attempts": 1, "code_length": 3477}}
{"function": "x^3 + 6*x^2 + 9*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + 6*x**2 + 9*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + 6x^{2} + 9x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + 6x^{2} + 9x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 12x + 9\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 12x + 9\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 12*x + 9\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic derivative", "metadata": {"attempts": 1, "code_length": 3519}}
{"function": "sin(x) + 3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) + 3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x) + 3\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x) + 3\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\sin(x)+c] = \\cos(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "sine shifted 3", "metadata": {"attempts": 1, "code_length": 3458}}
{"function": "e^(x^2 + x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0.5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x**2 + x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x^2 + x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x^2 + x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^u] = e^u u' \\text{ where } u=x^2+x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x^2+x} (2x+1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = (2x+1)e^{x^2+x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (2*x + 1) * np.exp(x**2 + x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp of quad linear", "metadata": {"attempts": 1, "code_length": 3512}}
{"function": "2*x^3 + x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-40, 60, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**3 + x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{3} + x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{3} + x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2(3)x^{2} + 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 6x^{2} + 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 6*x**2 + 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled cubic quad", "metadata": {"attempts": 1, "code_length": 3497}}
{"function": "cos(x^3)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x**3)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x^3)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x^3)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x^3) \\cdot 3x^2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -3x^2 \\sin(x^3)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -3 * x**2 * np.sin(x**3)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cosine of cube", "metadata": {"attempts": 1, "code_length": 3511}}
{"function": "sqrt(x) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(x) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5]) # Start x_range slightly above 0 for sqrt\n        func_label = MathTex(r\"f(x) = \\sqrt{x} + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sqrt{x} + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}x^{-1/2} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker in valid domain\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * x**(-0.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "shifted square root", "metadata": {"attempts": 1, "code_length": 3582}}
{"function": "4*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 4*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 4x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 4x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[cx] = c\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quadruple linear", "metadata": {"attempts": 1, "code_length": 3415}}
{"function": "x/(x^3 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x / (x**3 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x}{x^3 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x}{x^3 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"(\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1(x^3+1) - x(3x^2)}{(x^3+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1 - 2x^3}{(x^3 + 1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (1 - 2*x**3) / ((x**3 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "x over cubic plus", "metadata": {"attempts": 1, "code_length": 3544}}
{"function": "x^3 + x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic with quadratic", "metadata": {"attempts": 1, "code_length": 3488}}
{"function": "-x^4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{4}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{4}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -4x^{3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -4x^{3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -4*x**3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative quartic", "metadata": {"attempts": 1, "code_length": 3451}}
{"function": "x^4 - x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 - x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} - x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} - x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} - 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} - 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 - 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quartic minus x", "metadata": {"attempts": 1, "code_length": 3469}}
{"function": "sin(x) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 2.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x) + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x) + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\sin(x)+c] = \\cos(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "shifted sine up", "metadata": {"attempts": 1, "code_length": 3463}}
{"function": "sqrt(e^x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 8, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{e^x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[e^{g(x)}] = e^{g(x)}g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x/2} \\cdot \\frac{1}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2}e^{x/2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.exp(x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "root of exponential", "metadata": {"attempts": 1, "code_length": 3509}}
{"function": "x^3 + ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + np.log(x) if x > 0 else np.nan\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rules: } (x^n)'=nx^{n-1}, (\\ln x)'=\\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 1/x if x > 0 else np.nan\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic plus log", "metadata": {"attempts": 1, "code_length": 3555}}
{"function": "x/sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            # Handle division by zero for sin(x) = 0\n            if np.sin(x) == 0:\n                return np.nan # Return NaN to avoid plotting at asymptotes\n            return x / np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x}{\\sin(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x}{\\sin(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\sin(x) - x\\cos(x)}{\\sin^2(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\sin(x) - x\\cos(x)}{\\sin^2(x)}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            # Handle division by zero for sin(x) = 0\n            if np.sin(x) == 0:\n                return np.nan\n            return (np.sin(x) - x * np.cos(x)) / (np.sin(x)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "reciprocal sinc", "metadata": {"attempts": 1, "code_length": 3861}}
{"function": "0.5*x^5", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-25, 25, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * x**5\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.5, 2.5])\n        func_label = MathTex(r\"f(x) = 0.5x^{5}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.5x^{5}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.5 \\cdot 5x^{4}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2.5x^{4}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2.5 * x**4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "half quintic", "metadata": {"attempts": 1, "code_length": 3476}}
{"function": "sin(x)*sin(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) * np.sin(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x)\\sin(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x)\\sin(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x)\\sin(2x) + 2\\sin(x)\\cos(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x)\\sin(2x) + 2\\sin(x)\\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x) * np.sin(2*x) + np.sin(x) * 2 * np.cos(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "sine product", "metadata": {"attempts": 1, "code_length": 3581}}
{"function": "x^3 - x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic minus linear", "metadata": {"attempts": 2, "code_length": 3470}}
{"function": "ln(tan(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(np.tan(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(\\tan(x))\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(\\tan(x))\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\ln(g(x))] = \\frac{g'(x)}{g(x)}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\sec^2(x)}{\\tan(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\csc(x)\\sec(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (np.sin(x) * np.cos(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "log of tangent", "metadata": {"attempts": 1, "code_length": 3535}}
{"function": "cos(x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x^{2})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x^{2})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x^{2}) \\cdot 2x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2x \\sin(x^{2})\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 * x * np.sin(x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cosine of square", "metadata": {"attempts": 1, "code_length": 3512}}
{"function": "-2*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -2 * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -2\\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -2\\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\sin(x)] = \\cos(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative scaled sine", "metadata": {"attempts": 1, "code_length": 3459}}
{"function": "x*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5]) # Adjusted x_range for ln(x) domain\n        func_label = MathTex(r\"f(x) = x \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (1)\\ln(x) + x(1/x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\ln(x) + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker within the domain of ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.log(x) + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "x times logarithm", "metadata": {"attempts": 1, "code_length": 3555}}
{"function": "1.5*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1.5 * x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 1.5x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 1.5x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1.5 \\cdot 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 * x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "one-half quadratic", "metadata": {"attempts": 1, "code_length": 3462}}
{"function": "ln(cos(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            # Ensure cos(x) > 0 for ln to be defined\n            if np.cos(x) > 0:\n                return np.log(np.cos(x))\n            return np.nan # Return NaN for undefined points\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.5, 1.5]) # Restrict x_range for plotting ln(cos(x))\n        func_label = MathTex(r\"f(x) = \\ln(\\cos(x))\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(\\cos(x))\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(u)] = u'/u\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{-\\sin(x)}{\\cos(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\tan(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1) # Start within the defined range\n        \n        # Define derivative function\n        def f_prime(x):\n            # Ensure cos(x) > 0 for derivative to be defined\n            if np.cos(x) > 0:\n                return -np.tan(x)\n            return np.nan\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Smaller range for tangent to avoid undefined areas\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1), run_time=3, rate_func=smooth) # Animate within defined range\n        self.wait(1)", "level": "application", "description": "log of cosine", "metadata": {"attempts": 1, "code_length": 3902}}
{"function": "x^3 + x^2 - x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-30, 60, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + x**2 - x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + x^{2} - x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + x^{2} - x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 2x^{1} - 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 2x - 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 2*x - 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic quad minus x", "metadata": {"attempts": 2, "code_length": 3514}}
{"function": "2*tan(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.tan(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2\\tan(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2\\tan(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\tan(x)] = \\sec^2(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2\\sec^2(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\\sec^2(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 / (np.cos(x)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled tangent", "metadata": {"attempts": 1, "code_length": 3466}}
{"function": "x^5 + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-40, 40, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**5 + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.5, 2.5]) # Adjusted x_range for better visibility of x^5\n        func_label = MathTex(r\"f(x) = x^{5} + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{5} + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 5x^{4} + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 5x^{4} + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 5*x**4 + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.8, x_tracker.get_value()+0.8], # Adjusted tangent length for steepness\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quintic linear", "metadata": {"attempts": 1, "code_length": 3559}}
{"function": "(x^2 + 1)/(x^3 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return (x**2 + 1) / (x**3 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x^2 + 1}{x^3 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^2 + 1}{x^3 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{2x(x^3+1) - (x^2+1)3x^2}{(x^3+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{-x^4 - 3x^2 + 2x}{(x^3 + 1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (-x**4 - 3*x**2 + 2*x) / ((x**3 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "quad plus over cubic plus", "metadata": {"attempts": 1, "code_length": 3611}}
{"function": "x^3 + 3*x^2 - 9*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 30, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + 3*x**2 - 9*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + 3x^{2} - 9x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + 3x^{2} - 9x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 6x - 9\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 6x - 9\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 6*x - 9\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic inflection", "metadata": {"attempts": 1, "code_length": 3517}}
{"function": "x^2*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-12, 2, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x \\cos(x) - x^{2} \\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x \\cos(x) - x^{2} \\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x*np.cos(x) - x**2*np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quadratic cosine product", "metadata": {"attempts": 1, "code_length": 3528}}
{"function": "sin(x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x)\\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x)\\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos^2(x) - \\sin^2(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "product of trig", "metadata": {"attempts": 1, "code_length": 3496}}
{"function": "x^3 - 3*x^2 + 3*x - 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-30, 10, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 3*x**2 + 3*x - 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 3x^{2} + 3x - 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 3x^{2} + 3x - 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 6x + 3\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 6x + 3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 6*x + 3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative cubic expansion", "metadata": {"attempts": 2, "code_length": 3529}}
{"function": "3*x^3 - x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3*x**3 - x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3x^{3} - x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3x^{3} - x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 9x^{2} - 2x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 9x^{2} - 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 9*x**2 - 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "triple cubic quad", "metadata": {"attempts": 1, "code_length": 3489}}
{"function": "e^(x)*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) * x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x}x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x}x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x}x^{2} + e^{x}(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}(x^{2} + 2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (x**2 + 2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp quad product alt", "metadata": {"attempts": 1, "code_length": 3502}}
{"function": "e^(-x)*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-12, 2, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(-x) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{-x} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{-x} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -e^{-x}\\sin(x) + e^{-x}\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{-x}(\\cos(x) - \\sin(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(-x) * (np.cos(x) - np.sin(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "damped oscillation", "metadata": {"attempts": 1, "code_length": 3545}}
{"function": "e^(sin(x))*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 6, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(np.sin(x)) * x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x e^{\\sin(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x e^{\\sin(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{\\sin(x)} + x e^{\\sin(x)}\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{\\sin(x)}(1 + x\\cos(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(np.sin(x)) * (1 + x * np.cos(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "exp sine times x", "metadata": {"attempts": 1, "code_length": 3548}}
{"function": "e^x + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 40, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rules: } \\frac{d}{dx}[e^x]=e^x, \\frac{d}{dx}[x]=1\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x} + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x} + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp plus x", "metadata": {"attempts": 1, "code_length": 3482}}
{"function": "x/sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-0.5, 4, 1], # Adjusted x_range to start near 0 for sqrt(x)\n            y_range=[-1, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5]) # Start x_range from a small positive value\n        func_label = MathTex(r\"f(x) = \\frac{x}{\\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}x^{-1/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker from a positive value\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * x**(-0.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.01, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure tangent x_range is positive\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Animate to a positive x value\n        self.wait(1)", "level": "application", "description": "x over root", "metadata": {"attempts": 1, "code_length": 3712}}
{"function": "sin(x) + 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) + 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x) + 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x) + 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\sin(x)+c] = \\cos(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "shifted sine up 2", "metadata": {"attempts": 1, "code_length": 3458}}
{"function": "sqrt(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{x + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = (x+1)^{1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[u^n] = nu^{n-1}u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}(x+1)^{-1/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2\\sqrt{x+1}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0) # Start within the domain of sqrt(x+1)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * (x + 1)**(-0.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(-1, x_tracker.get_value()-1.5), min(3.5, x_tracker.get_value()+1.5)], # Adjust range to stay within function domain\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "shifted root input", "metadata": {"attempts": 1, "code_length": 3616}}
{"function": "e^x/sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            # Handle domain for sqrt(x)\n            if x <= 0:\n                return np.nan\n            return np.exp(x) / np.sqrt(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5]) # Start x_range from a small positive value\n        func_label = MathTex(r\"f(x) = \\frac{e^x}{\\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{e^x}{\\sqrt{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{e^x \\sqrt{x} - e^x/(2\\sqrt{x})}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{e^x(2x-1)}{2x\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker at a valid point\n        \n        # Define derivative function\n        def f_prime(x):\n            if x <= 0:\n                return np.nan\n            return np.exp(x) * (2*x - 1) / (2 * x * np.sqrt(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.01, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Adjust x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Animate within valid domain\n        self.wait(1)", "level": "application", "description": "exp over root", "metadata": {"attempts": 2, "code_length": 3892}}
{"function": "2*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = 2\\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2\\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[\\ln(x)] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), min(3.5, x_tracker.get_value()+1.5)],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled logarithm", "metadata": {"attempts": 1, "code_length": 3492}}
{"function": "-x^3 + 3*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 80, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**3 + 3*x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{3} + 3x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{3} + 3x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -3x^{2} + 6x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -3x^{2} + 6x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -3*x**2 + 6*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "negative cubic opt", "metadata": {"attempts": 1, "code_length": 3500}}
{"function": "x^2 + 6*x + 9", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 50, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + 6*x + 9\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + 6x + 9\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + 6x + 9\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + 6 + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x + 6\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x + 6\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "perfect square 2", "metadata": {"attempts": 1, "code_length": 3482}}
{"function": "sqrt(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(x**2 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{x^2 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sqrt{x^2 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } (f(g(x)))' = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2\\sqrt{x^2+1} \\cdot 2x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{x}{\\sqrt{x^2+1}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x / np.sqrt(x**2 + 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "root of quad plus", "metadata": {"attempts": 1, "code_length": 3527}}
{"function": "x^2 + 3*x + 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 8, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + 3*x + 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + 3x + 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + 3x + 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + 3 + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x + 3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x + 3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "complete quadratic 2", "metadata": {"attempts": 1, "code_length": 3481}}
{"function": "x^2*tan(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.tan(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.5, 1.5]) # Adjusted x_range to avoid asymptotes\n        func_label = MathTex(r\"f(x) = x^{2} \\tan(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\tan(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x \\tan(x) + x^{2} \\sec^{2}(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x \\tan(x) + x^{2} \\sec^{2}(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1) # Adjusted initial x_tracker to be within graph range\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x * np.tan(x) + x**2 * (1 / np.cos(x))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Adjusted tangent length\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1), run_time=3, rate_func=smooth) # Adjusted movement range\n        self.wait(1)", "level": "conceptual", "description": "quad tangent", "metadata": {"attempts": 1, "code_length": 3695}}
{"function": "x^5 + x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-40, 40, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**5 + x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.2, 2.2])\n        func_label = MathTex(r\"f(x) = x^{5} + x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{5} + x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 5x^{4} + 3x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 5x^{4} + 3x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 5*x**4 + 3*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quintic cubic", "metadata": {"attempts": 2, "code_length": 3497}}
{"function": "sqrt(x)*e^(-x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.1, 0.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.where(x >= 0, np.sqrt(x) * np.exp(-x), np.nan)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{x}e^{-x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sqrt{x}e^{-x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2\\sqrt{x}e^{-x} - \\sqrt{x}e^{-x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{e^{-x}(1-2x)}{2\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.where(x > 0, (np.exp(-x) * (1 - 2*x)) / (2 * np.sqrt(x)), np.nan)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "root decay", "metadata": {"attempts": 1, "code_length": 3622}}
{"function": "sin(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\sin(u)] = \\cos(u) \\cdot u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(2x) \\cdot 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\\cos(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.cos(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "compressed sine", "metadata": {"attempts": 1, "code_length": 3491}}
{"function": "0.25*x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-18, 18, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.25 * x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 0.25x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.25x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.25 \\cdot 3x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 0.75x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.75 * x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quarter cubic", "metadata": {"attempts": 1, "code_length": 3480}}
{"function": "x^3 + 3*x^2 - x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + 3*x**2 - x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + 3x^{2} - x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + 3x^{2} - x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 6x^{1} - 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 6x - 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 6*x - 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic mixed", "metadata": {"attempts": 1, "code_length": 3516}}
{"function": "ln(e^x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(np.exp(x) + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(e^x + 1)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(e^x + 1)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } (\\ln(u))' = u'/u\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{e^x}{e^x + 1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{e^x}{e^x + 1}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) / (np.exp(x) + 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "log exp sum", "metadata": {"attempts": 2, "code_length": 3510}}
{"function": "x^5 - x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-550, 550, 100],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**5 - x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{5} - x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{5} - x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 5x^{4} - 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 5x^{4} - 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 5*x**4 - 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quintic minus x", "metadata": {"attempts": 1, "code_length": 3474}}
{"function": "x^3*cos(x)*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-60, 10, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 * np.cos(x) * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5]) # Adjusted x_range for ln(x) domain\n        func_label = MathTex(r\"f(x) = x^{3} \\cos(x) \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} \\cos(x) \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"(uvw)' = u'vw + uv'w + uvw'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^2\\cos(x)\\ln(x) - x^3\\sin(x)\\ln(x) + x^2\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^2(3\\cos(x)\\ln(x) - x\\sin(x)\\ln(x) + \\cos(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker within the domain of ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 * np.cos(x) * np.log(x) - x**3 * np.sin(x) * np.log(x) + x**2 * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "cubic cosine log", "metadata": {"attempts": 1, "code_length": 3718}}
{"function": "3*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3 * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3\\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3\\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\cos(x)] = -\\sin(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3(-\\sin(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -3\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -3 * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "triple cosine", "metadata": {"attempts": 1, "code_length": 3459}}
{"function": "e^x*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x}\\sin(x) + e^{x}\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}(\\sin(x) + \\cos(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (np.sin(x) + np.cos(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp sine product", "metadata": {"attempts": 1, "code_length": 3538}}
{"function": "x^2 + 2*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + 2*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + 2x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + 2x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + 2x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x + 2\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x + 2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quadratic with 2x", "metadata": {"attempts": 1, "code_length": 3471}}
{"function": "e^x/x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            if x == 0:\n                return np.nan # Handle division by zero for plotting\n            return np.exp(x) / (x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{e^x}{x^2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{e^x}{x^2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{x^2 e^x - 2x e^x}{x^4}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{e^x(x-2)}{x^3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            if x == 0:\n                return np.nan # Handle division by zero for plotting\n            return (np.exp(x) * (x - 2)) / (x**3)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp over quadratic", "metadata": {"attempts": 1, "code_length": 3735}}
{"function": "ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(x)] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "natural logarithm", "metadata": {"attempts": 1, "code_length": 3444}}
{"function": "sin(x^2)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x**2) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x^2)\\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x^2)\\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x\\cos(x^2)\\cos(x) - \\sin(x^2)\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\\cos(x^2)\\cos(x) - \\sin(x^2)\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x*np.cos(x**2)*np.cos(x) - np.sin(x**2)*np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "sine square cosine", "metadata": {"attempts": 1, "code_length": 3590}}
{"function": "e^(-x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(-x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{-x} \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{-x} \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -e^{-x}\\cos(x) - e^{-x}\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -e^{-x}(\\cos(x) + \\sin(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.exp(-x) * (np.cos(x) + np.sin(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "damped cosine", "metadata": {"attempts": 1, "code_length": 3548}}
{"function": "x^3 - 9*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 9*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 9x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 9x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 9\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 9\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 9\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic simple", "metadata": {"attempts": 1, "code_length": 3474}}
{"function": "x*sqrt(x)*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**(1.5) * np.sin(x) if x >= 0 else np.nan\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3/2} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3/2} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{3}{2}x^{1/2}\\sin(x) + x^{3/2}\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^{1/2}(\\frac{3}{2}\\sin(x) + x\\cos(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1.5 * x**(0.5) * np.sin(x) + x**(1.5) * np.cos(x) if x >= 0 else np.nan\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x root sine", "metadata": {"attempts": 1, "code_length": 3626}}
{"function": "-x^4 + 4*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**4 + 4*x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{4} + 4x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{4} + 4x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -4x^{3} + 8x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -4x^{3} + 8x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -4*x**3 + 8*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "negative quartic", "metadata": {"attempts": 1, "code_length": 3497}}
{"function": "ln(x^3)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-7, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x**3)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5]) # Adjusted x_range for ln(x^3)\n        func_label = MathTex(r\"f(x) = \\ln(x^3)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x^3)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } (\\ln u)' = u'/u\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{3x^2}{x^3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{3}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker at a positive value for ln(x^3)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), min(3.5, x_tracker.get_value()+1.5)], # Adjusted x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "log of cube", "metadata": {"attempts": 2, "code_length": 3589}}
{"function": "x*e^(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.exp(2 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 1.5]) # Adjusted x_range for better visualization of this function\n        func_label = MathTex(r\"f(x) = xe^{2x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = xe^{2x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{2x} + 2xe^{2x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{2x}(1 + 2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(2 * x) * (1 + 2 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1), run_time=3, rate_func=smooth) # Adjusted end value for better visualization\n        self.wait(1)", "level": "conceptual", "description": "x fast exponential", "metadata": {"attempts": 1, "code_length": 3600}}
{"function": "x^2*e^(-2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.2, 1, 0.2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.exp(-2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} e^{-2x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} e^{-2x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2xe^{-2x} - 2x^{2}e^{-2x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2xe^{-2x}(1-x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x * np.exp(-2*x) * (1 - x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad fast decay", "metadata": {"attempts": 1, "code_length": 3521}}
{"function": "0.5*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 0.5e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.5e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[ce^x] = ce^x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.5e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 0.5e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "half exponential", "metadata": {"attempts": 1, "code_length": 3466}}
{"function": "1/(x + 2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1/(x + 2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{1}{x + 2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = (x+2)^{-1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[u^n] = nu^{n-1}u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -1(x+2)^{-2}(1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{(x+2)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -1 / ((x + 2)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "reciprocal shifted 2", "metadata": {"attempts": 1, "code_length": 3498}}
{"function": "x^3 + 2*x^2 + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + 2*x**2 + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + 2x^{2} + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + 2x^{2} + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 4x^{1} + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 4x + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 4*x + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic 2quad linear", "metadata": {"attempts": 2, "code_length": 3516}}
{"function": "x^4 - 8*x^2 + 16", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 70, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 - 8*x**2 + 16\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} - 8x^{2} + 16\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} - 8x^{2} + 16\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} - 16x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} - 16x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 - 16*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quartic critical", "metadata": {"attempts": 1, "code_length": 3507}}
{"function": "x*e^x*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 12, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.exp(x) * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 2.0])\n        func_label = MathTex(r\"f(x) = x e^x \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x e^x \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uvw)' = u'vw + uv'w + uvw'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^x \\ln(x) + x e^x \\ln(x) + e^x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^x (\\ln(x) + x \\ln(x) + 1)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker within the valid domain for ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (np.log(x) + x * np.log(x) + 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Adjusted range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1.8), run_time=3, rate_func=smooth) # Animate within valid x_range\n        self.wait(1)", "level": "advanced", "description": "x exp log", "metadata": {"attempts": 1, "code_length": 3678}}
{"function": "x^2 - 9", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 8, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 - 9\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} - 9\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} - 9\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quadratic shifted -9", "metadata": {"attempts": 1, "code_length": 3454}}
{"function": "sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 2.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}x^{-1/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (2 * np.sqrt(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "square root", "metadata": {"attempts": 1, "code_length": 3498}}
{"function": "-cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.cos(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -\\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -\\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -(-\\sin(2x)) \\cdot 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.sin(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative compressed cosine", "metadata": {"attempts": 1, "code_length": 3499}}
{"function": "-sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.sqrt(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.9])\n        func_label = MathTex(r\"f(x) = -\\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\frac{1}{2}x^{-1/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{2\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -0.5 * x**(-0.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative square root", "metadata": {"attempts": 1, "code_length": 3497}}
{"function": "x^4 + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4 * x**3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quartic shifted", "metadata": {"attempts": 1, "code_length": 3458}}
{"function": "x^2*e^(-x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 30, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.exp(-x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} e^{-x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} e^{-x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2xe^{-x} - x^{2}e^{-x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = (2x - x^{2})e^{-x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (2*x - x**2) * np.exp(-x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad decay", "metadata": {"attempts": 1, "code_length": 3510}}
{"function": "e^(tan(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(np.tan(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.5, 1.5]) # Adjusted x_range to avoid asymptotes for better visualization\n        func_label = MathTex(r\"f(x) = e^{\\tan(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{\\tan(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } (e^{g(x)})' = e^{g(x)}g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{\\tan(x)} \\cdot \\sec^2(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{\\tan(x)} \\sec^2(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(np.tan(x)) * (1 / np.cos(x))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Smaller range for tangent to avoid issues near asymptotes\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1), run_time=3, rate_func=smooth) # Adjusted range for tracker\n        self.wait(1)", "level": "advanced", "description": "exp of tangent", "metadata": {"attempts": 1, "code_length": 3690}}
{"function": "sin(x)/x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) / (x**2) if x != 0 else 0 # Handle division by zero for plotting\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\sin(x)}{x^2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\sin(x)}{x^2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{x^2\\cos(x) - 2x\\sin(x)}{x^4}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{x\\cos(x) - 2\\sin(x)}{x^3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (x * np.cos(x) - 2 * np.sin(x)) / (x**3) if x != 0 else 0 # Handle division by zero\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine over quad", "metadata": {"attempts": 1, "code_length": 3685}}
{"function": "ln(x) - 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) - 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x) - 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x) - 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(x)] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x} - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "log shifted -2", "metadata": {"attempts": 1, "code_length": 3462}}
{"function": "e^(-x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 8, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(-x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{-x/2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{-x/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[e^u] = e^u u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{-x/2} \\cdot (-\\frac{1}{2})\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{2}e^{-x/2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -0.5 * np.exp(-x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "slow decay", "metadata": {"attempts": 1, "code_length": 3506}}
{"function": "sqrt(sin(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(np.sin(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, np.pi - 0.1])\n        func_label = MathTex(r\"f(x) = \\sqrt{\\sin(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sqrt{\\sin(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}(\\sin(x))^{-1/2}\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos(x)}{2\\sqrt{\\sin(x)}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.cos(x) * (np.sin(x))**(-0.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(np.pi - 0.2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "root of sine", "metadata": {"attempts": 1, "code_length": 3590}}
{"function": "3*x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-50, 50, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3*x**3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3x^{3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3x^{3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3 \\cdot 3x^{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 9x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 9*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "triple cubic", "metadata": {"attempts": 1, "code_length": 3459}}
{"function": "e^x/(sin(x) + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) / (np.sin(x) + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{e^x}{\\sin(x) + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{e^x}{\\sin(x) + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"\\frac{e^x(\\sin x+1) - e^x\\cos x}{(\\sin x+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^x \\frac{1+\\sin x-\\cos x}{(1+\\sin x)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (np.sin(x) + 1 - np.cos(x)) / (np.sin(x) + 1)**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "exp over sine plus", "metadata": {"attempts": 1, "code_length": 3637}}
{"function": "x^2 + 4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[3, 21, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + 4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + 4\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + 4\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quadratic shifted 4", "metadata": {"attempts": 1, "code_length": 3453}}
{"function": "cos(x)*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-35, 35, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x) * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x)e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x)e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x)e^{x} + \\cos(x)e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}(\\cos(x) - \\sin(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (np.cos(x) - np.sin(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cosine exponential product", "metadata": {"attempts": 1, "code_length": 3537}}
{"function": "0.5*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 1, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 0.5 * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 0.5 \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 0.5 \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\cos(x)] = -\\sin(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.5(-\\sin(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -0.5 \\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -0.5 * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "half cosine", "metadata": {"attempts": 1, "code_length": 3476}}
{"function": "-x^2 + 4*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**2 + 4*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{2} + 4x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{2} + 4x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2x^{1} + 4\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2x + 4\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2*x + 4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative quadratic linear", "metadata": {"attempts": 1, "code_length": 3472}}
{"function": "-x + 5", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x + 5\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x + 5\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x + 5\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[x] = 1, \\frac{d}{dx}[c] = 0\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -1 + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "negative linear shifted", "metadata": {"attempts": 1, "code_length": 3432}}
{"function": "x^2 + 4*x + 3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + 4*x + 3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + 4x + 3\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + 4x + 3\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} + 4x^{0} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x + 4\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x + 4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "complete quadratic 3", "metadata": {"attempts": 1, "code_length": 3487}}
{"function": "sin(x) - cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) - np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x) - \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x) - \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\sin(x)] = \\cos(x), \\frac{d}{dx}[\\cos(x)] = -\\sin(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x) - (-\\sin(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x) + \\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x) + np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "difference of trig", "metadata": {"attempts": 1, "code_length": 3542}}
{"function": "3*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3 * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3\\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3\\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\sin(x)] = \\cos(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "triple sine", "metadata": {"attempts": 1, "code_length": 3453}}
{"function": "ln(x)*cos(x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) * np.cos(x**2) if x > 0 else np.nan\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x)\\cos(x^2)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x)\\cos(x^2)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\cos(x^2)}{x} - 2x\\ln(x)\\sin(x^2)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos(x^2)}{x} - 2x\\ln(x)\\sin(x^2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Adjusted start to be in domain of ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (np.cos(x**2)/x - 2*x*np.log(x)*np.sin(x**2)) if x > 0 else np.nan\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Adjusted x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Adjusted end to be in domain\n        self.wait(1)", "level": "advanced", "description": "log cosine square", "metadata": {"attempts": 1, "code_length": 3736}}
{"function": "sin(x)/cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.tan(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\sin(x)}{\\cos(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\sin(x)}{\\cos(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\cos^2(x) + \\sin^2(x)}{\\cos^2(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\sec^2(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (np.cos(x)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "tangent form", "metadata": {"attempts": 1, "code_length": 3546}}
{"function": "(x^3 + 2*x)/(x^2 + 4)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return (x**3 + 2*x) / (x**2 + 4)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x^3 + 2x}{x^2 + 4}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^3 + 2x}{x^2 + 4}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{3x^4+14x^2+8 - (2x^4+4x^2)}{(x^2+4)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{x^4 + 10x^2 + 8}{(x^2 + 4)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (x**4 + 10*x**2 + 8) / ((x**2 + 4)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "cubic linear over quad 4", "metadata": {"attempts": 1, "code_length": 3615}}
{"function": "x^2*ln(x)*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-6, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.log(x) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\ln(x) \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\ln(x) \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Prod. Rule: } (uvw)' = u'vw + uv'w + uvw'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = x(2\\ln x \\sin x + \\sin x + x\\ln x \\cos x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x(2\\ln x \\sin x + \\sin x + x\\ln x \\cos x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x * np.log(x) * np.sin(x) + x * np.sin(x) + x**2 * np.log(x) * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "quad log sine", "metadata": {"attempts": 1, "code_length": 3635}}
{"function": "-x^2 + 5", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-12, 6, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -x**2 + 5\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -x^{2} + 5\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -x^{2} + 5\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2x^{1} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "inverted quadratic up 5", "metadata": {"attempts": 1, "code_length": 3460}}
{"function": "x^3*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 2.5]) # Adjusted x_range for better visibility\n        func_label = MathTex(r\"f(x) = x^{3} e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2}e^{x} + x^{3}e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^{2}e^{x}(3+x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x**2 * np.exp(x) * (3 + x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic exponential product", "metadata": {"attempts": 1, "code_length": 3548}}
{"function": "-sin(x) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -np.sin(x) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = -\\sin(x) + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -\\sin(x) + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[-\\sin(x)] = -\\cos(x), \\frac{d}{dx}[1] = 0\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\cos(x) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "negative sine shifted", "metadata": {"attempts": 1, "code_length": 3486}}
{"function": "ln(x + 3)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x + 3)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.9, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x + 3)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x + 3)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\ln(u)] = \\frac{u'}{u}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x+3} \\cdot 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x+3}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (x + 3)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "log shifted input 3", "metadata": {"attempts": 1, "code_length": 3497}}
{"function": "2*x^3 - 3*x^2 - 12*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-90, 10, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**3 - 3*x**2 - 12*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^3 - 3x^2 - 12x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^3 - 3x^2 - 12x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 6x^2 - 6x^1 - 12x^0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 6x^2 - 6x - 12\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 6*x**2 - 6*x - 12\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "scaled cubic", "metadata": {"attempts": 1, "code_length": 3521}}
{"function": "x*sin(x) + cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x*np.sin(x) + np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\sin(x) + \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\sin(x) + \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\sin(x) + x\\cos(x) - \\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x*np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x sine plus cosine", "metadata": {"attempts": 1, "code_length": 3511}}
{"function": "x/(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.7, 0.7, 0.2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x / (x**2 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x}{x^2 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x}{x^2 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1(x^2+1) - x(2x)}{(x^2+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1-x^2}{(x^2+1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (1 - x**2) / ((x**2 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "rational with denom", "metadata": {"attempts": 1, "code_length": 3564}}
{"function": "cos(x/2) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 2.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x/2) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x/2) + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x/2) + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\cos(u)] = -\\sin(u)u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x/2) \\cdot \\frac{1}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{2}\\sin(x/2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -0.5 * np.sin(x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "stretched cosine shifted", "metadata": {"attempts": 1, "code_length": 3530}}
{"function": "tan(x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-7, 7, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.tan(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.0, 3.0]) # Adjusted x_range to avoid asymptotes too close to edge\n        func_label = MathTex(r\"f(x) = \\tan(x/2)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\tan(x/2)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\tan(u)] = \\sec^2(u) \\cdot u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\sec^2(x/2) \\cdot \\frac{1}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2}\\sec^2(x/2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * (1 / np.cos(x/2))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "stretched tangent", "metadata": {"attempts": 1, "code_length": 3569}}
{"function": "e^(-2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(-2 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.5, 3.5]) # Adjusted x_range for better visibility of e^(-2x)\n        func_label = MathTex(r\"f(x) = e^{-2x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{-2x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[e^{g(x)}] = e^{g(x)}g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{-2x} \\cdot (-2)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2e^{-2x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-0.5) # Adjusted initial x_tracker for better visibility\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 * np.exp(-2 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "fast decay", "metadata": {"attempts": 1, "code_length": 3600}}
{"function": "ln(sin(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            # Ensure sin(x) > 0 for ln to be defined\n            if np.sin(x) > 0:\n                return np.log(np.sin(x))\n            else:\n                return np.nan # Return NaN for undefined regions\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.0]) # Adjusted x_range to avoid log(0) and negative sin(x)\n        func_label = MathTex(r\"f(x) = \\ln(\\sin(x))\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(\\sin(x))\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\ln(g(x))] = \\frac{g'(x)}{g(x)}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\cos(x)}{\\sin(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cot(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker in a valid domain\n        \n        # Define derivative function\n        def f_prime(x):\n            # Ensure sin(x) != 0 for cot(x) to be defined\n            if np.sin(x) != 0:\n                return np.cos(x) / np.sin(x)\n            else:\n                return np.nan\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Smaller range for tangent to avoid crossing asymptotes\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2.5), run_time=3, rate_func=smooth) # Animate within valid domain\n        self.wait(1)", "level": "application", "description": "log of sine", "metadata": {"attempts": 1, "code_length": 4011}}
{"function": "x*e^(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.exp(2 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x e^{2x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x e^{2x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (1)e^{2x} + x(2e^{2x})\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{2x}(1 + 2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(2 * x) * (1 + 2 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x fast exponential", "metadata": {"attempts": 1, "code_length": 3500}}
{"function": "2*x^5", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-80, 80, 20],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * x**5\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.5, 2.5])\n        func_label = MathTex(r\"f(x) = 2x^{5}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{5}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[cx^n] = cnx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\cdot 5x^{5-1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 10x^{4}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 10 * x**4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5], # Adjusted range for steepness\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled quintic", "metadata": {"attempts": 1, "code_length": 3500}}
{"function": "x*tan(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.tan(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\tan(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\tan(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\tan(x) + x \\sec^2(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\tan(x) + x \\sec^2(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.tan(x) + x * (1 / np.cos(x))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x tangent product", "metadata": {"attempts": 1, "code_length": 3512}}
{"function": "cos(x^2)*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x**2) * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x^2)\\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x^2)\\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2x\\ln(x)\\sin(x^2) + \\frac{\\cos(x^2)}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2x\\ln(x)\\sin(x^2) + \\frac{\\cos(x^2)}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (-2 * x * np.sin(x**2) * np.log(x)) + (np.cos(x**2) / x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "cosine square log", "metadata": {"attempts": 1, "code_length": 3593}}
{"function": "2*e^(x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 16, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.exp(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2e^{x/2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2e^{x/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[e^{u}] = e^{u}u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2e^{x/2} \\cdot \\frac{1}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x/2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled slow exponential", "metadata": {"attempts": 1, "code_length": 3488}}
{"function": "sin(2*x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(2*x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(2x)\\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(2x)\\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2\\cos(2x)\\cos(x) - \\sin(2x)\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2\\cos(2x)\\cos(x) - \\sin(2x)\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.cos(2*x) * np.cos(x) - np.sin(2*x) * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "compressed sine cosine", "metadata": {"attempts": 1, "code_length": 3581}}
{"function": "x^2*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 17, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x \\ln(x) + x^{2} \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x \\ln(x) + x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * x * np.log(x) + x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), min(3.5, x_tracker.get_value()+1.5)],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quadratic log product", "metadata": {"attempts": 1, "code_length": 3533}}
{"function": "x^2*sin(x)/cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.tan(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-1.5, 1.5]) # Adjusted x_range for plotting to avoid asymptotes\n        func_label = MathTex(r\"f(x) = x^{2} \\tan(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} \\tan(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x \\tan(x) + x^{2} \\sec^{2}(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x \\tan(x) + x^{2} \\sec^{2}(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1) # Adjusted initial x_tracker value to be within the plot range\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x * np.tan(x) + x**2 * (1/np.cos(x))**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.8, x_tracker.get_value()+0.8], # Adjusted tangent length\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(1), run_time=3, rate_func=smooth) # Adjusted end value for x_tracker\n        self.wait(1)", "level": "advanced", "description": "quad sine over cosine", "metadata": {"attempts": 1, "code_length": 3724}}
{"function": "x*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x) - x\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x) - x\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x) - x * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "product with cosine", "metadata": {"attempts": 1, "code_length": 3495}}
{"function": "sin(x)/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 1.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) / x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\sin(x)}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\sin(x)}{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\cos(x)x - \\sin(x)}{x^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{x\\cos(x) - \\sin(x)}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (np.cos(x) * x - np.sin(x)) / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quotient with trig", "metadata": {"attempts": 1, "code_length": 3574}}
{"function": "sin(x)*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[0, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x)\\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x)\\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x)\\ln(x) + \\frac{\\sin(x)}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x)\\ln(x) + \\frac{\\sin(x)}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x) * np.log(x) + np.sin(x) / x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine log product", "metadata": {"attempts": 1, "code_length": 3552}}
{"function": "cos(x)^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 1.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x)**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos^2(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos^2(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[u^n] = nu^{n-1}u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2\\cos(x)(-\\sin(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.sin(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cosine squared", "metadata": {"attempts": 1, "code_length": 3489}}
{"function": "e^(-x)*cos(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-7, 7, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(-x) * np.cos(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{-x} \\cos(2x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{-x} \\cos(2x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -e^{-x}\\cos(2x) - 2e^{-x}\\sin(2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -e^{-x}(\\cos(2x) + 2\\sin(2x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.exp(-x) * np.cos(2*x) - 2 * np.exp(-x) * np.sin(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "decay compressed cosine", "metadata": {"attempts": 1, "code_length": 3575}}
{"function": "x^2 + 10", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[5, 30, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + 10\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + 10\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + 10\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quadratic shifted 10", "metadata": {"attempts": 1, "code_length": 3452}}
{"function": "x^2 + x*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 + x*np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} + x \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} + x \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rules: Power, Sum, Product}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x + (1)\\sin(x) + x\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x + \\sin(x) + x\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x + np.sin(x) + x*np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad plus x sine", "metadata": {"attempts": 1, "code_length": 3528}}
{"function": "x^3 - 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-50, 50, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic shifted down", "metadata": {"attempts": 1, "code_length": 3463}}
{"function": "sqrt(3*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(3*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{3x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sqrt{3x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain/Power Rule: } \\frac{d}{dx}[u^n] = nu^{n-1}u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}(3x)^{-1/2} \\cdot 3\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{3}{2\\sqrt{3x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 / (2 * np.sqrt(3*x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "root of triple x", "metadata": {"attempts": 1, "code_length": 3522}}
{"function": "x*ln(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.log(x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-0.9, 3.5])\n        func_label = MathTex(r\"f(x) = x \\ln(x + 1)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\ln(x + 1)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\ln(x+1) + x \\frac{1}{x+1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\ln(x+1) + \\frac{x}{x+1}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.1)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.log(x + 1) + x / (x + 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x shifted log", "metadata": {"attempts": 1, "code_length": 3522}}
{"function": "x^3 - 8", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-25, 10, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 8\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2.5, 2.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 8\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 8\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic shifted -8", "metadata": {"attempts": 1, "code_length": 3462}}
{"function": "sin(sqrt(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 1.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(np.sqrt(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(\\sqrt{x})\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(\\sqrt{x})\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g)] = f'(g)g'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(\\sqrt{x}) \\cdot \\frac{1}{2\\sqrt{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos(\\sqrt{x})}{2\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.1)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(np.sqrt(x)) / (2 * np.sqrt(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sine of root", "metadata": {"attempts": 1, "code_length": 3572}}
{"function": "sin(x) + cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) + np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x) + \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x) + \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Sum Rule: } (u+v)' = u'+v'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x) - \\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x) - \\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x) - np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "sum of trig", "metadata": {"attempts": 1, "code_length": 3506}}
{"function": "x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "linear function", "metadata": {"attempts": 1, "code_length": 3423}}
{"function": "3/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3/x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3x^{-1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3x^{-1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3(-1)x^{-2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{3}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -3 / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "triple reciprocal", "metadata": {"attempts": 2, "code_length": 3465}}
{"function": "cos(x) + 3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x) + 3\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x) + 3\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x) + 3\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\cos(x)] = -\\sin(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "cosine shifted 3", "metadata": {"attempts": 1, "code_length": 3460}}
{"function": "x^2 - 3*x + 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 - 3*x + 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} - 3x + 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} - 3x + 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1} - 3(1) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x - 3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x - 3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "factored quadratic 2", "metadata": {"attempts": 1, "code_length": 3485}}
{"function": "x^4 + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 20, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} + 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quartic linear", "metadata": {"attempts": 3, "code_length": 3469}}
{"function": "x^4 - 4*x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 - 4*x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} - 4x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} - 4x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} - 8x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} - 8x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 - 8*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quartic optimization", "metadata": {"attempts": 1, "code_length": 3492}}
{"function": "sin(x^2)*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x**2) * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x^2)e^x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x^2)e^x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^x(2x\\cos(x^2) + \\sin(x^2))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^x(2x\\cos(x^2) + \\sin(x^2))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (2*x * np.cos(x**2) + np.sin(x**2))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "sine square exp", "metadata": {"attempts": 2, "code_length": 3556}}
{"function": "x^3 - 4*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 4*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 4x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 4x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 4x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 4\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic two roots", "metadata": {"attempts": 1, "code_length": 3477}}
{"function": "1/(x - 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1 / (x - 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{1}{x - 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = (x - 1)^{-1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[u^n] = nu^{n-1}u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -1(x - 1)^{-2}(1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{(x - 1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -1 / ((x - 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "reciprocal x minus 1", "metadata": {"attempts": 2, "code_length": 3508}}
{"function": "2*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2\\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2\\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[\\cos(x)] = -\\sin(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2(-\\sin(x))\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled cosine", "metadata": {"attempts": 1, "code_length": 3473}}
{"function": "x^2/sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 7, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            if x <= 0: # Function is only defined for x > 0\n                return np.nan\n            return x**(3/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5]) # Start slightly above 0 for sqrt(x)\n        func_label = MathTex(r\"f(x) = \\frac{x^2}{\\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x^2}{\\sqrt{x} = x^{3/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{3}{2}x^{1/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{3}{2}\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker at a positive value\n        \n        # Define derivative function\n        def f_prime(x):\n            if x <= 0: # Derivative also undefined for x <= 0\n                return np.nan\n            return (3/2) * np.sqrt(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.01, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure tangent range is valid\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Animate within valid x range\n        self.wait(1)", "level": "application", "description": "quad over root", "metadata": {"attempts": 1, "code_length": 3855}}
{"function": "ln(3*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-0.5, 4, 1], # Adjusted x_range for ln(x)\n            y_range=[-2, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(3*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5]) # Adjusted x_range for plotting\n        func_label = MathTex(r\"f(x) = \\ln(3x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(3x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\ln(u)] = \\frac{u'}{u}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{3}{3x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Adjusted initial value for ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Adjusted x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Adjusted end value\n        self.wait(1)", "level": "conceptual", "description": "log of triple x", "metadata": {"attempts": 1, "code_length": 3630}}
{"function": "e^x/x^3", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-6, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) / (x**3)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5], discontinuities=[0])\n        func_label = MathTex(r\"f(x) = \\frac{e^x}{x^3}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{e^x}{x^3}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{e^x x^3 - 3e^x x^2}{x^6}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{e^x(x-3)}{x^4}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (np.exp(x) * (x - 3)) / (x**4)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp over cubic", "metadata": {"attempts": 1, "code_length": 3574}}
{"function": "x^3 - 6*x^2 + 9*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-15, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 6*x**2 + 9*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 6x^{2} + 9x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 6x^{2} + 9x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 12x^{1} + 9x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 12x + 9\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 12*x + 9\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic factored", "metadata": {"attempts": 2, "code_length": 3528}}
{"function": "(x + 1)/e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-8, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return (x + 1) / np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{x+1}{e^x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{x+1}{e^x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{e^x - (x+1)e^x}{e^{2x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{x}{e^x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -x / np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "linear over exp", "metadata": {"attempts": 1, "code_length": 3530}}
{"function": "sqrt(x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(x) * np.cos(x) if x >= 0 else np.nan\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{x}\\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sqrt{x}\\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\cos(x)}{2\\sqrt{x} - \\sqrt{x}\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos(x)}{2\\sqrt{x} - \\sqrt{x}\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.1) # Start x_tracker at a small positive value to avoid sqrt(0) and division by zero\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.nan if x <= 0 else 0.5 * x**(-0.5) * np.cos(x) - np.sqrt(x) * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "root cosine", "metadata": {"attempts": 1, "code_length": 3715}}
{"function": "e^x + 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) + 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} + 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} + 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Rule: } \\frac{d}{dx}[e^x] = e^x\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "exponential shifted 2", "metadata": {"attempts": 1, "code_length": 3455}}
{"function": "sin(x + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(x + 1)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(x + 1)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x+1) \\cdot 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x+1)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x + 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "phase shifted sine", "metadata": {"attempts": 1, "code_length": 3495}}
{"function": "x^3 - x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic minus x squared", "metadata": {"attempts": 1, "code_length": 3489}}
{"function": "sqrt(ln(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[0, 4, 1],\n            y_range=[-0.5, 2, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(np.log(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[1.01, 3.9])\n        func_label = MathTex(r\"f(x) = \\sqrt{\\ln(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sqrt{\\ln(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2\\sqrt{\\ln(x)} \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2x\\sqrt{\\ln(x)}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(1.1)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (2 * x * np.sqrt(np.log(x)))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-0.5, x_tracker.get_value()+0.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "root of log", "metadata": {"attempts": 1, "code_length": 3568}}
{"function": "ln(x^2)*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x**2) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x^2)\\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x^2)\\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{2}{x}\\sin(x) + \\ln(x^2)\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{2\\sin(x)}{x} + \\ln(x^2)\\cos(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (2/x) * np.sin(x) + np.log(x**2) * np.cos(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "log squared sine", "metadata": {"attempts": 1, "code_length": 3573}}
{"function": "e^x + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 15, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x} + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x} + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[e^x] = e^x, \\frac{d}{dx}[c] = 0\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "exponential shifted", "metadata": {"attempts": 1, "code_length": 3462}}
{"function": "x^3 + 3*x^2 + 3*x + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 30, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 + 3*x**2 + 3*x + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} + 3x^{2} + 3x + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} + 3x^{2} + 3x + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} + 6x^{1} + 3\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} + 6x + 3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 + 6*x + 3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "cubic expansion", "metadata": {"attempts": 1, "code_length": 3532}}
{"function": "x^2 - 4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 - 4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} - 4\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} - 4\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "quadratic shifted down 4", "metadata": {"attempts": 1, "code_length": 3450}}
{"function": "x + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[x] = 1, \\frac{d}{dx}[c] = 0\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1 + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "linear with constant", "metadata": {"attempts": 1, "code_length": 3426}}
{"function": "e^(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{2x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{2x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{2x} \\cdot 2\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2e^{2x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.exp(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "fast exponential", "metadata": {"attempts": 1, "code_length": 3481}}
{"function": "3*sin(3*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3 * np.sin(3 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3\\sin(3x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3\\sin(3x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3\\cos(3x) \\cdot 3\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 9\\cos(3x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 9 * np.cos(3 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "triple scaled compressed", "metadata": {"attempts": 1, "code_length": 3499}}
{"function": "-2*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return -2 * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = -2 \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = -2 \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(x)] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -2 \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{2}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker at a positive value for ln(x)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 / x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), min(3.5, x_tracker.get_value()+1.5)], # Ensure tangent stays in domain\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Animate to x=3\n        self.wait(1)", "level": "conceptual", "description": "negative scaled log", "metadata": {"attempts": 1, "code_length": 3586}}
{"function": "cos(x)/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x) / x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\cos(x)}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\cos(x)}{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{-\\sin(x) \\cdot x - \\cos(x) \\cdot 1}{x^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{x\\sin(x) + \\cos(x)}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (-x * np.sin(x) - np.cos(x)) / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cosine over x", "metadata": {"attempts": 2, "code_length": 3586}}
{"function": "1.5*sqrt(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1.5 * np.sqrt(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.01, 3.5]) # Adjusted x_range for sqrt(x)\n        func_label = MathTex(r\"f(x) = 1.5 \\sqrt{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 1.5 \\sqrt{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 0.75 x^{-1/2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{0.75}{\\sqrt{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.1) # Start x_tracker at a small positive value\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.75 * x**(-0.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.01, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Ensure x_range for tangent is valid\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Animate to a valid x value\n        self.wait(1)", "level": "conceptual", "description": "one-half square root", "metadata": {"attempts": 1, "code_length": 3654}}
{"function": "2*x^2 + x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 40, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**2 + x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{2} + x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{2} + x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[ax^n] = anx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2(2x^{1}) + 1x^{0}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x + 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x + 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled quadratic plus x", "metadata": {"attempts": 1, "code_length": 3476}}
{"function": "sin(3*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(3*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin(3x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(3x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(3x) \\cdot 3\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3\\cos(3x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3 * np.cos(3*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "triple frequency sine", "metadata": {"attempts": 1, "code_length": 3488}}
{"function": "e^(-x^2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 1.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(-x**2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{-x^2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{-x^2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[e^{g(x)}] = e^{g(x)}g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{-x^2} \\cdot (-2x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -2xe^{-x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -2 * x * np.exp(-x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "gaussian function", "metadata": {"attempts": 1, "code_length": 3507}}
{"function": "(x^2 + 1)/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return (x**2 + 1) / x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5], discontinuities=[0])\n        func_label = MathTex(r\"f(x) = \\frac{x^2 + 1}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x + x^{-1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1 - 1x^{-2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1 - \\frac{1}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 - 1 / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad plus over x", "metadata": {"attempts": 1, "code_length": 3518}}
{"function": "x^3 - 3*x + 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 3*x + 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 3x + 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 3x + 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 3x^{0} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2} - 3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2 - 3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic standard form", "metadata": {"attempts": 1, "code_length": 3495}}
{"function": "e^(2*x)*cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(2*x) * np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{2x} \\cos(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{2x} \\cos(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2e^{2x}\\cos(x) - e^{2x}\\sin(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{2x}(2\\cos(x) - \\sin(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(2*x) * (2*np.cos(x) - np.sin(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "fast exp cosine", "metadata": {"attempts": 1, "code_length": 3551}}
{"function": "cos(x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x/2)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x/2)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\cos(u)] = -\\sin(u)u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x/2) \\cdot \\frac{1}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{2}\\sin(x/2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -0.5 * np.sin(x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "stretched cosine", "metadata": {"attempts": 1, "code_length": 3514}}
{"function": "2*x^2 + 4*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 40, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2*x**2 + 4*x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 2x^{2} + 4x\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x^{2} + 4x\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2(2x^{1}) + 4(1)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x + 4\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x + 4\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled quadratic with linear", "metadata": {"attempts": 1, "code_length": 3476}}
{"function": "x^2*e^(2*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 100, 10], # Adjusted y_range for visibility up to x approx 1.6\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.exp(2*x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 1.6]) # Adjusted x_range for graph to fit y_range\n        func_label = MathTex(r\"f(x) = x^{2} e^{2x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} e^{2x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (2x)e^{2x} + x^{2}(2e^{2x})\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2xe^{2x}(1 + x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x*np.exp(2*x)*(1+x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement (adjusted end value to keep dot on screen within y_range)\n        self.play(x_tracker.animate.set_value(1.6), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad fast exponential", "metadata": {"attempts": 1, "code_length": 3668}}
{"function": "x^4 - x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 15, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 - x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} - x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} - x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3} - 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 4x^{3} - 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 4*x**3 - 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "difference of even powers", "metadata": {"attempts": 1, "code_length": 3488}}
{"function": "sin(x)*cos(x)*tan(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-0.5, 1.5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x)**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\sin^2(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin^2(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[u^n] = nu^{n-1}u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2\\sin(x)\\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\sin(2x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.sin(2*x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "triple trig product", "metadata": {"attempts": 1, "code_length": 3482}}
{"function": "x*cos(x) - sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-7, 7, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.cos(x) - np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\cos(x) - \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\cos(x) - \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (\\cos(x) - x\\sin(x)) - \\cos(x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -x \\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -x * np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x cosine minus sine", "metadata": {"attempts": 1, "code_length": 3520}}
{"function": "sin(x)/cos(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sin(x) / np.cos(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\sin(x)}{\\cos(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\sin(x)}{\\cos(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\frac{u}{v}] = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{\\cos^2(x) + \\sin^2(x)}{\\cos^2(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\sec^2(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1 / (np.cos(x)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "tangent quotient", "metadata": {"attempts": 2, "code_length": 3546}}
{"function": "cos(x) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x) + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x) + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\cos(x) + c] = -\\sin(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x) + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\sin(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.sin(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "shifted cosine up", "metadata": {"attempts": 1, "code_length": 3465}}
{"function": "x^2*e^x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 35, 5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.exp(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} e^{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} e^{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x e^{x} + x^{2} e^{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = (x^{2} + 2x)e^{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (x**2 + 2*x) * np.exp(x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "product rule example", "metadata": {"attempts": 1, "code_length": 3505}}
{"function": "x*e^(cos(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.exp(np.cos(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x e^{\\cos(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x e^{\\cos(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{\\cos(x)} - x \\sin(x) e^{\\cos(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = e^{\\cos(x)}(1 - x \\sin(x))\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(np.cos(x)) * (1 - x * np.sin(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "x exp cosine", "metadata": {"attempts": 2, "code_length": 3550}}
{"function": "x^4*e^(-x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-10, 120, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**4 * np.exp(-x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{4} e^{-x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{4} e^{-x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 4x^{3}e^{-x} - x^{4}e^{-x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = x^{3}e^{-x}(4 - x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return x**3 * np.exp(-x) * (4 - x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quartic decay", "metadata": {"attempts": 1, "code_length": 3519}}
{"function": "cos(x)*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 1, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x) * np.log(x) if x > 0 else np.nan\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x) \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x) \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x)\\ln(x) + \\frac{\\cos(x)}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos(x)}{x} - \\sin(x)\\ln(x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (np.cos(x) / x) - (np.sin(x) * np.log(x)) if x > 0 else np.nan\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cosine log product", "metadata": {"attempts": 1, "code_length": 3602}}
{"function": "2*x*ln(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 9, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 2 * x * np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = 2x \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 2x \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2 \\ln(x) + 2x(1/x)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2 \\ln(x) + 2\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2 * np.log(x) + 2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "scaled x log", "metadata": {"attempts": 1, "code_length": 3485}}
{"function": "x*ln(x)^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-0.5, 4, 1],\n            y_range=[-1, 6, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * (np.log(x))**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = x (\\ln(x))^2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x (\\ln(x))^2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (\\ln x)^2 + 2\\ln x\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\ln(x)(\\ln(x) + 2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.log(x) * (np.log(x) + 2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x log squared", "metadata": {"attempts": 1, "code_length": 3520}}
{"function": "x^3 - 27", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-70, 20, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**3 - 27\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{3} - 27\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{3} - 27\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3x^{2} - 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3x^{2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3*x**2\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "cubic shift large", "metadata": {"attempts": 1, "code_length": 3466}}
{"function": "x*cos(x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x * np.cos(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\cos(x/2)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\cos(x/2)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(x/2) - \\frac{x}{2}\\sin(x/2)\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\cos(x/2) - \\frac{x}{2}\\sin(x/2)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.cos(x/2) - (x/2) * np.sin(x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "x stretched cosine", "metadata": {"attempts": 1, "code_length": 3537}}
{"function": "sqrt(sin(x))*x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            # Ensure sin(x) is non-negative for sqrt\n            if np.sin(x) < 0:\n                return np.nan\n            return np.sqrt(np.sin(x)) * x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x \\sqrt{\\sin(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x \\sqrt{\\sin(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 1 \\cdot \\sqrt{\\sin(x)} + x \\cdot \\frac{\\cos(x)}{2\\sqrt{\\sin(x)}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\sqrt{\\sin(x)} + \\frac{x\\cos(x)}{2\\sqrt{\\sin(x)}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            # Ensure sin(x) is positive for derivative\n            if np.sin(x) <= 0:\n                return np.nan\n            return np.sqrt(np.sin(x)) + x * np.cos(x) / (2 * np.sqrt(np.sin(x)))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "root sine times x", "metadata": {"attempts": 1, "code_length": 3858}}
{"function": "log(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(x)] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "logarithm base 10", "metadata": {"attempts": 1, "code_length": 3444}}
{"function": "e^(x/2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 8, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(x/2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = e^{x/2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{x/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[e^{g(x)}] = e^{g(x)}g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = e^{x/2} \\cdot \\frac{1}{2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2}e^{x/2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * np.exp(x/2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "slow exponential", "metadata": {"attempts": 1, "code_length": 3506}}
{"function": "ln(x) + 2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) + 2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x) + 2\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x) + 2\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(x)+c] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "log shifted 2", "metadata": {"attempts": 1, "code_length": 3462}}
{"function": "ln(x) + 1", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) + 1\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\ln(x) + 1\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\ln(x) + 1\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\frac{d}{dx}[\\ln(x)] = \\frac{1}{x}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{x} + 0\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1/x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "shifted logarithm", "metadata": {"attempts": 1, "code_length": 3460}}
{"function": "3*x - 4", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-18, 10, 2],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 3*x - 4\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = 3x - 4\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = 3x - 4\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Linear Rule: } \\frac{d}{dx}[ax+b] = a\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 3\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 3\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 3\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "scaled linear shifted", "metadata": {"attempts": 1, "code_length": 3431}}
{"function": "x^2*e^x*sin(x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-50, 50, 10],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2 * np.exp(x) * np.sin(x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2} e^{x} \\sin(x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2} e^{x} \\sin(x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Product Rule: } (uv)' = u'v + uv'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = (x^2)'e^x\\sin x + x^2(e^x\\sin x)'\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = xe^x(2\\sin x + x\\sin x + x\\cos x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return np.exp(x) * (2*x*np.sin(x) + x**2*np.sin(x) + x**2*np.cos(x))\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "quad exp sine", "metadata": {"attempts": 1, "code_length": 3599}}
{"function": "cos(0.5*x)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(0.5 * x)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(0.5x)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(0.5x)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[\\cos(u)] = -\\sin(u)u'\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(0.5x) \\cdot 0.5\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -0.5\\sin(0.5x)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -0.5 * np.sin(0.5 * x)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "half frequency cosine", "metadata": {"attempts": 1, "code_length": 3510}}
{"function": "1/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-5, 5, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return 1/x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{1}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{-1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -1x^{-2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\frac{1}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -1 / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "reciprocal function", "metadata": {"attempts": 3, "code_length": 3465}}
{"function": "cos(x - 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.cos(x - 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\cos(x - 1)\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\cos(x - 1)\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = -\\sin(x-1) \\cdot 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = -\\sin(x-1)\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return -np.sin(x - 1)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "phase shifted cosine", "metadata": {"attempts": 1, "code_length": 3498}}
{"function": "sin(ln(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-2, 2, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            # Ensure x > 0 for np.log\n            if x <= 0:\n                return np.nan\n            return np.sin(np.log(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5]) # Adjusted x_range for ln(x)\n        func_label = MathTex(r\"f(x) = \\sin(\\ln(x))\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\sin(\\ln(x))\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\cos(\\ln(x)) \\cdot \\frac{1}{x}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{\\cos(\\ln(x))}{x}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker at a positive value\n        \n        # Define derivative function\n        def f_prime(x):\n            # Ensure x > 0 for np.log\n            if x <= 0:\n                return np.nan\n            return np.cos(np.log(x)) / x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[max(0.1, x_tracker.get_value()-1.5), x_tracker.get_value()+1.5], # Adjusted x_range for tangent\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3), run_time=3, rate_func=smooth) # Adjusted animation range\n        self.wait(1)", "level": "application", "description": "sine of log", "metadata": {"attempts": 1, "code_length": 3852}}
{"function": "x^2", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 10, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return x**2\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = x^{2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = x^{2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Power Rule: } \\frac{d}{dx}[x^n] = nx^{n-1}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = 2x^{1}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 2x\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return 2*x\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "foundation", "description": "basic quadratic", "metadata": {"attempts": 1, "code_length": 3438}}
{"function": "(2*x^2 + x)/(x^2 + 1)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return (2*x**2 + x)/(x**2 + 1)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-3.5, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{2x^2 + x}{x^2 + 1}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{2x^2 + x}{x^2 + 1}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{(4x+1)(x^2+1) - (2x^2+x)(2x)}{(x^2+1)^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{-x^2 + 4x + 1}{(x^2 + 1)^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-2)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (-x**2 + 4*x + 1) / ((x**2 + 1)**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "advanced", "description": "scaled quad over quad plus", "metadata": {"attempts": 1, "code_length": 3610}}
{"function": "ln(x)/x", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[-1.5, 0.5, 0.5],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.log(x) / x\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5])\n        func_label = MathTex(r\"f(x) = \\frac{\\ln(x)}{x}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = \\frac{\\ln(x)}{x}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Quotient Rule: } (\\frac{u}{v})' = \\frac{u'v - uv'}{v^2}\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{(1/x)x - \\ln(x)(1)}{x^2}\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1 - \\ln(x)}{x^2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5)\n        \n        # Define derivative function\n        def f_prime(x):\n            return (1 - np.log(x)) / (x**2)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(3.5), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "log over x", "metadata": {"attempts": 1, "code_length": 3554}}
{"function": "sqrt(x + 2)", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 3, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.sqrt(x + 2)\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[-2, 3.5])\n        func_label = MathTex(r\"f(x) = \\sqrt{x + 2}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = (x+2)^{1/2}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Chain Rule: } \\frac{d}{dx}[f(g(x))] = f'(g(x))g'(x)\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f'(x) = \\frac{1}{2}(x+2)^{-1/2} \\cdot 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = \\frac{1}{2\\sqrt{x+2}\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(-1.9) # Start slightly after -2 to avoid division by zero for derivative\n        \n        # Define derivative function\n        def f_prime(x):\n            return 0.5 * (x + 2)**(-0.5)\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "conceptual", "description": "root input shifted 2", "metadata": {"attempts": 1, "code_length": 3596}}
{"function": "e^(ln(x))", "code": "from manim import *\nimport numpy as np\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # PART 1: Setup axes and function\n        axes = Axes(\n            x_range=[-4, 4, 1],\n            y_range=[0, 4, 1],\n            x_length=5.5,\n            y_length=4.5,\n            axis_config={\"color\": GRAY}\n        ).shift(LEFT * 2.5)\n        \n        # Define the function\n        def f(x):\n            return np.exp(np.log(x))\n        \n        # Plot the function\n        graph = axes.plot(f, color=BLUE, x_range=[0.1, 3.5]) # Adjusted x_range for log\n        func_label = MathTex(r\"f(x) = e^{\\ln(x)}\", color=BLUE, font_size=36).to_corner(UL).shift(DOWN*0.3)\n        \n        # PART 2: CALCULATION STEPS (Right side, no overlap)\n        calc_title = Text(\"Derivative Calculation:\", font_size=20, color=WHITE).to_edge(RIGHT).shift(LEFT*0.2 + UP*3.3)\n        \n        calc_step1 = MathTex(r\"f(x) = e^{\\ln(x)}\", font_size=22).next_to(calc_title, DOWN, buff=0.3, aligned_edge=LEFT)\n        calc_step2 = MathTex(r\"\\text{Recall: } e^{\\ln(u)} = u\", font_size=22).next_to(calc_step1, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_step3 = MathTex(r\"f(x) = x \\implies f'(x) = 1\", font_size=22).next_to(calc_step2, DOWN, buff=0.25, aligned_edge=LEFT)\n        calc_final = MathTex(r\"f'(x) = 1\", font_size=26, color=YELLOW).next_to(calc_step3, DOWN, buff=0.3, aligned_edge=LEFT)\n        \n        # Ensure all calculation steps fit on screen\n        calc_steps = VGroup(calc_title, calc_step1, calc_step2, calc_step3, calc_final)\n        if calc_steps.width > 3.8:\n            calc_steps.scale_to_fit_width(3.8)\n        \n        # PART 3: Moving elements\n        x_tracker = ValueTracker(0.5) # Start x_tracker within valid domain\n        \n        # Define derivative function\n        def f_prime(x):\n            return 1\n        \n        # Moving dot on curve\n        dot = always_redraw(lambda: Dot(\n            axes.c2p(x_tracker.get_value(), f(x_tracker.get_value())),\n            color=RED,\n            radius=0.08\n        ))\n        \n        # Tangent line\n        tangent = always_redraw(lambda: axes.plot(\n            lambda x: f_prime(x_tracker.get_value()) * (x - x_tracker.get_value()) + f(x_tracker.get_value()),\n            x_range=[x_tracker.get_value()-1.5, x_tracker.get_value()+1.5],\n            color=GREEN\n        ))\n        \n        # Derivative value display - positioned BELOW calculation to avoid overlap\n        deriv_label = always_redraw(lambda: MathTex(\n            r\"f'({:.1f}) = {:.2f}\".format(x_tracker.get_value(), f_prime(x_tracker.get_value())),\n            font_size=30,\n            color=YELLOW\n        ).next_to(calc_steps, DOWN, buff=0.5))\n        \n        # PART 4: Animation sequence\n        self.play(Create(axes), Write(func_label), run_time=1)\n        self.play(Create(graph), run_time=1.5)\n        self.wait(0.5)\n        \n        # Show calculation steps one by one\n        self.play(Write(calc_title), run_time=0.5)\n        self.play(Write(calc_step1), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step2), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_step3), run_time=0.7)\n        self.wait(0.3)\n        self.play(Write(calc_final), run_time=0.8)\n        self.wait(0.5)\n        \n        # Add moving elements\n        self.play(Create(dot), Create(tangent), Write(deriv_label), run_time=1)\n        \n        # Animate movement\n        self.play(x_tracker.animate.set_value(2), run_time=3, rate_func=smooth)\n        self.wait(1)", "level": "application", "description": "exp of log", "metadata": {"attempts": 1, "code_length": 3516}}
